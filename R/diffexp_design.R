
## Handling needed packages
cran_list <- c('BiocManager', 'matrixStats', 'circlize', 'BiocParallel', 'ggplot2', 'amap', 'knitr', 'writexl', 'randomcoloR', 'data.table', 'RColorBrewer', 'EnvStats', 'openxlsx')
for (pkgn in cran_list) if(! pkgn %in% installed.packages()) install.packages(pkgn)
bioc_list <- c('DESeq2', 'ComplexHeatmap', 'IHW', 'limma', 'msigdbr', 'clusterProfiler', 'ReactomePA', 'meshes', 'GSVA')
for (pkgn in bioc_list) if(! pkgn %in% installed.packages()) install.packages(pkgn)
gith_list <- list('omnideconv' = 'omnideconv/immunedeconv')
for (pkgn in names(gith_list)) if(! pkgn %in% installed.packages()) remotes::install_github(gith_list[[pkgn]])

## Read the "Raw.genes.tsv(.gz)" output matrix generated by the bulk RNAseq pipeline
## output_feature_type can be 'default' (first column) or 'symbol' (will look for a 'Hugo_ID' column)
read_pipeline_matrix <- function(file = NULL, output_feature_type = 'Symbol') {
  ## Checks
  if (is.null(file)) stop('Input files are required !')
  if (!file.exists(file)) stop('Provided file does not exist !')
  
  ## Load file
  datal <- read.table(file = file, header = TRUE, sep = '\t', na.strings = 'NA', check.names = FALSE, as.is = TRUE)
  
  ## Check the presence of the symbol column if requested
  if (tolower(output_feature_type) == 'symbol') {
    if (! 'Hugo_ID' %in% colnames(datal)) stop('Requested output feature type is SYMBOL, but no Hugo_ID column found !')
    datal <- datal[!datal$Hugo_ID == 'Unknown',]
    rowc <- matrixStats::rowCounts(x = as.matrix(datal[,-c(1, which(colnames(datal) == 'Hugo_ID'))]), value = 0)
    ## Remove replicated symbols (keeping the most expressed)
    symbtbl <- table(datal$Hugo_ID)
    dupsymb <- names(symbtbl[symbtbl > 1])
    for (dp in dupsymb) {
      dp_rowc <- rowc[datal$Hugo_ID == dp]
      # print(dp_rowc)
      dp_torem <- names(dp_rowc)[-which.min(dp_rowc)[1]]
      datal <- datal[!rownames(datal) %in% dp_torem,]
      rowc <- rowc[!names(rowc) %in% dp_torem]
    }
    ret_mat <- as.matrix(datal[,-c(1, which(colnames(datal) == 'Hugo_ID'))])
    rownames(ret_mat) <- datal$Hugo_ID
  } else {
    ret_mat <- as.matrix(datal[,-c(1, which(colnames(datal) == 'Hugo_ID'))])
    rownames(ret_mat) <- datal[,1]
  }
  ret_mat <- round(ret_mat)
  ret_mat <- ret_mat[,order(colnames(ret_mat))]
  return(ret_mat)
}
    

## Function to assess the weight of annotation covariates in a (sample x annotations) data.frame, on a (feature x sample) data matrix, through correlation (for a continuous covariate) or Kruskal-Wallis statistic (for factors)
## . mat                [f x s num matrix]      A normalized numeric matrix
## . annot.df           [s x a data.frame]      A data.frame with covariates as columns (numeric or factor)
## . factor.names       [vec(char)]             Column names of annot.df corresponding to factor covariates
## . conti.colnames     [vec(char)]             Column names of annot.df corresponding to contiunous covariates
## . red.method         [char]                  Dimension reduction method ['PCA', 'MDS.euc', 'MDS.spear']
## . ndim.max           [int>0]                 Number of dimensions to compute and plot
## . center             [bool]                  Center mat ?
## . scale              [bool]                  Scale mat ?
## . coef.cut           [0<=num<1]              Do not display coefficients inferior to this value on the heatmap
## . color.palette      [vec(col)]              Color vector (length 2) for the heatmap
## . out.file           [char]                  Output PNG file name (and path)
assess_covar <- function(mat = NULL, annot.df = NULL, factor.names = NULL, conti.names = NULL, red.method = 'pca', ndim.max = 10, topvar = NULL, center = TRUE, scale = TRUE, coef.cut = 0, color.palette = c("white", "orangered3"), out.file = paste0(getwd(), '/Assess_covariates.png')) {
  ## Checks
  ### Mandatory
  if (is.null(mat)) stop('A (f feature by s sample) matrix [mat] is required.')
  if (is.null(annot.df)) stop('An annotation data.frame [annot.df] is required.')
  if (all(is.null(c(factor.names, conti.names)))) stop('At least one of [factor.names] or [conti.colnames] should not be NULL.')
  if (ndim.max <= 0) stop('[ndim.max] should be a non-null positive integer (and <= s samples).')
  if (!dir.exists(dirname(out.file))) stop('Path to [out.file] does not exist.')
  if (!tolower(red.method) %in% c('pca', 'mds.euc', 'mds.spear')) stop('Unknown reduction method')
  ### Compatibility
  if (ndim.max > ncol(mat)) {
    message('WARNING : requested [ndim.max] is higher than samples in [mat]. Reducing it to [mat] samples.')
    ndim.max <- ncol(mat)-1
  }
  # message(ndim.max)
  if (nrow(annot.df) != ncol(mat)) stop('There should be the same number of samples in [mat] (columns) and [annot.df] (rows)')
  if(!is.null(factor.names)) {
    if(!all(factor.names %in% colnames(annot.df))) stop('All [factor.names] should be in colnames of [annot.df].')
  }
  if(!is.null(conti.names)) {
    if(!all(conti.names %in% colnames(annot.df))) stop('All [conti.names] should be in colnames of [annot.df].')
  }
  
  ## RUN
  
  ## Restrict to topvar ?
  if(!is.null(topvar)) {
    message('Restricting to the Top ', topvar, ' features ...')
    svmat <- matrixStats::rowVars(mat)
    mat <- mat[order(svmat) <= topvar,]
  }
  
  ## Center / scale ?
  if (any(c(center, scale))) mat <- base::scale(x = mat, center = center, scale = scale)
  ## Dimension reduction
  if (tolower(red.method) == 'pca') norm.red <- base::svd(x = mat, nv = ndim.max)$v
  if (tolower(red.method) == 'mds.euc') norm.red <- stats::cmdscale(d = dist(x = t(mat), method = 'euclidean'), k = ndim.max)
  if (tolower(red.method) == 'mds.spear') norm.red <- stats::cmdscale(d = as.dist(1-cor(mat, method = 'spearman')), k = ndim.max)
  col.names <- c(factor.names, conti.names)
  col.types <- c(rep('factor', length(factor.names)), rep('continuous', length(conti.names)))
  ## Setting output matrix
  bc.mat <- matrix(NA, ncol = length(col.names), nrow = ndim.max, dimnames = list(paste0(toupper(red.method), seq_len(ndim.max)), col.names))
  ## Filling matrix
  for (cn in seq_along(col.names)) {
    # message(col.names[cn])
    if (col.names[cn] %in% conti.names) {
      cv2cor <- annot.df[[col.names[cn]]]
      nona <- !is.na(cv2cor)
      bc.mat[, cn] <-  abs(cor(x = cv2cor[nona], y = norm.red[nona,], method = 'spearman'))
    } else if (col.names[cn] %in% factor.names & length(unique(annot.df[[col.names[cn]]])) > 1) {
      b2kw <- annot.df[[col.names[cn]]]
      nona <- !is.na(b2kw)
      for (si in seq_len(ndim.max)) {
        k_test <- try(k_res <- kruskal.test(x = norm.red[nona,si], g = as.factor(b2kw[nona])), silent = TRUE)
        if (!is(k_test, class2 = 'try-error')) {
          bc.mat[si,cn] <- k_res$statistic / nrow(norm.red)
        } else bc.mat[si,cn] <- 0
      }
    }
  }
  bc.mat[bc.mat < coef.cut] <- 0
  ## Heatmap
  myRamp.col <- circlize::colorRamp2(c(0, 1), color.palette)
  BC.hm <- ComplexHeatmap::Heatmap(matrix = bc.mat,
                                   name = 'Weight',
                                   col = myRamp.col,
                                   na_col = 'grey75',
                                   cluster_rows = FALSE,
                                   cluster_columns = FALSE,
                                   rect_gp = grid::gpar(col = "darkgrey", lwd=0.5),
                                   column_title = 'Batch factors and covariates weight on dataset',
                                   row_title = 'SVD dimensions',
                                   column_split = col.types,
                                   top_annotation = ComplexHeatmap::HeatmapAnnotation(Type = col.types, col = list(Type = setNames(object = c('lightblue','pink'), nm = c('factor', 'continuous')))))
  png(filename = out.file, width = 800, heigh = 1000)
  ComplexHeatmap::draw(BC.hm)
  dev.off()
}

## Converts a factor to a design dataframe to be used in DE.test
## Function to generated a "full" comparison design from a minimalistic dataframe containing samplenames and factor(s) to compare, to use in DE.test
## . init_df            [data.frame]      A data.frame with at least 2 columns, one of which should be named as defined in [samples_colname], the others being the factors to use to generate the comparison design
## . samples_colname    [char]            Name of the column to use from init_df as sample names
## . covar_colnames     [list(vec(char))]       Name of the column(s) to use in the design as covariates to regress. They should not be in [init_df] !
## . add_inverted       [logical]         Add the inverted comparisons of the default factor ones (ie, B_vs_A if A_vs_B is the default one)
## . add_others         [logical]         Add the 'X vs Other' type of comparisons if the factor has more than 2 levels
## . only_others        [logical]         Only generate the 'X vs Other' type of comparisons if the factor has more than 2 levels
full_design_generator <- function(init_df = NULL, samples_colname = NULL, covar_colnames = NULL, add_inverted = TRUE, add_others = TRUE, only_others = FALSE) {
  
  ## Checks
  if(is.null(init_df)) stop('A starting dataframe containing sample names and factors to compare is  required !')
  if(is.null(samples_colname)) stop('A column name to identify samples in init_df is required !')
  if(!samples_colname %in% colnames(init_df)) stop('Column name [', samples_colname, '] not found in init_df !')
  if(!add_others & only_others) stop("Can't restrict to 'vs_Other' comparisons if add_others is not set to TRUE !")
  if(length(covar_colnames) != (ncol(init_df)-1)) stop ('length(covar_colnames) != nrow(init_df) !')
  
  ## Cleaning bad chars
  ### Column names in initial df
  colnames(init_df) <- gsub(pattern = "\\W", replacement = '.', x = colnames(init_df))
  ### Content of initial df
  for (myc in seq_len(ncol(init_df))) init_df[[myc]] <- gsub(pattern = "\\W", replacement = '.', x = init_df[[myc]])
  ### samples_colname & covar_colnames
  # covar_colnames <- gsub(pattern = "\\W", replacement = '.', x = covar_colnames)
  covar_colnames[vapply(covar_colnames, is.null, TRUE)] <- ''
  covar_colnames <- lapply(covar_colnames, function(x) { gsub(pattern = "\\W", replacement = '.', x = x) })
  samples_colname <- gsub(pattern = "\\W", replacement = '.', x = samples_colname)
  
  
  
  factor_colnames <- colnames(init_df)[!colnames(init_df) %in% samples_colname]
  
  des.df <- sapply(seq_along(factor_colnames), function(f) {
    factor_name <- factor_colnames[f]
    message(factor_name)
    my_factor <- init_df[[factor_name]]
    if(!is.factor(my_factor)) my_factor <- as.factor(my_factor)
    
    mylevels <- levels(my_factor)
    # combn.res <- if(invert_levels) combn(mylevels, 2) else combn(rev(mylevels), 2)
    combn.res <- combn(rev(mylevels), 2)
    if(add_inverted) combn.res <- cbind(combn.res, combn(mylevels, 2))
    all.combz <- sapply(1:ncol(combn.res), function(x) {list(combn.res[1,x], combn.res[2,x])}, simplify = FALSE)
    names(all.combz) <- vapply(1:ncol(combn.res), function(x) { paste(combn.res[, x, drop = TRUE], collapse = '_vs_') }, 'a')
    if(length(mylevels) > 2 & add_others) {
      XvsO.combz <- sapply(as.character(mylevels), function(x) { list(x, mylevels[!mylevels == x])}, simplify = FALSE)
      names(XvsO.combz) <- vapply(mylevels, function(x) { paste0(x, '_vs_Other') }, 'a')
      all.combz <- if(only_others) XvsO.combz else c(all.combz, XvsO.combz)
      rm(XvsO.combz)
    }
  
    ## Filtering comparisons with a class comprised by an unique sample
    for (mycomb in names(all.combz)) {
      class.len <- vapply(all.combz[[mycomb]], function(x) { length(which(my_factor %in% x))}, 1L)
      if(any(class.len == 1)) all.combz[[mycomb]] <- NULL
    }
    
    ## Generated design table
    f.df <- sapply(seq_along(all.combz), function(x) {
      comb_df <- data.frame(
        'Samples_colname' = samples_colname
        , 'Covar_colnames' = paste(covar_colnames[[f]], collapse = ',')
        , 'Condition_colname' = factor_name
        , 'Condition_A' = paste(all.combz[[x]][[1]], collapse = ',')
        , 'Condition_B' = paste(all.combz[[x]][[2]], collapse = ',')
        , 'Comparison_name' = names(all.combz)[x]
      )
      return(comb_df)
    }, simplify = FALSE)
    f.df = Reduce(f = rbind, x = f.df)
    return(f.df)
  }, simplify = FALSE)
  des.df <- Reduce(f = rbind, x = des.df)
  return(des.df)
}


## Perform DE analysis & functional enrichment for contrasts in pairs
## exp.mat                matrix(integer)     Sample x feature (gene) raw count matrix. Feature names as rownames.
## annot.df               data.frame          Sample annotations. Should contain a column with the same entries as colnames(exp.mat)
## design.df              data.frame          Design of comparisons to perform. Should contain these column names : [Samples_colname] = Column name of sample names ; [Covar_colnames] = Column name(s) of covariates to regress, coma-separated (can be empty if none to regress); [Condition_colname] = Column name of factor condition to explore for the differential analysis ; [Condition_A] = levels to consider as the condition A (test) ; [Condition_B] = levels to consider as the condition B (ref) ; [Comparison_name] = Name to use for results output.
## assess.factor          logical             Perform assessment of factor covariates using the provided column name(s) corresponding to factor data columns in annot.df
## assess.conti           logical             Perform assessment of continuous covariates using the provided column name(s) corresponding to continuous data columns in annot.df
## adjp.max               0<numeric<1         BH FDR-adjusted p-value cut-off to consider differential genes as significant
## lfc.min                numeric+            Minimal logFoldChange to consider differential genes
## ihw                    logical             Apply Independent Hypothesis Weighting (see IHW::ihw) [TRUE]
## outdir                 character           Path of the output directory
## samples.dist.method    character           Name of the distance method to use for the hierarchical clustering of samples
## samples.hclust.method  character           Name of the aggregation method to use for the hierarchical clustering of samples
## genes.dist.method      character           Name of the distance method to use for the hierarchical clustering of genes
## genes.hclust.method    character           Name of the aggregation method to use for the hierarchical clustering of genes
## msigdb.do              c(bool, bool)       Use the MSigDb dataset collection to perform GSEA/ORA
## go.do                  c(bool, bool)       Use the GeneOntology dataset to perform GSEA/ORA
## do.do                  c(bool, bool)       Use the DiseaseOntology + CancerGeneNetwork + DisGeNet datasets to perform GSEA/ORA
## kegg.do                c(bool, bool)       Use the KEGG dataset to perform GSEA/ORA
## wp.do                  c(bool, bool)       Use the WikiPathways dataset to perform GSEA/ORA
## reactome.do            c(bool, bool)       Use the Reactome dataset to perform GSEA/ORA
## cm.do                  c(bool, bool)       Use the CellMarker dataset to perform GSEA/ORA
## mesh.do                c(bool, bool)       Use the MeSHDb dataset collection to perform GSEA/ORA (warning, this may consume an astronomical amount of RAM. gsea.do is forced to false)
## species                character           Name of the species analyzed (namely, 'human' or 'mouse')
## enrp.max               0<numeric<1         BH FDR-adjusted p-value cut-off to consider enriched terms as significant
## enr.min.genes          numeric+            Minimum number of significant genes to perform GSEA/ORA
## or.top.max             numeric+            Maximum number of significant genes to consider as a signature for ORA. Also used for plots (boxplots, limited heatmap) using only a portion of all significant genes
## dotplot.maxterms       numeric+            Maximum number of enriched terms to plot in a dotplot (for readability)
## my.seed                numeric             Seed value for RNG (used for GSEA and heatmap annotation colors)
## boxplots               bool                If TRUE, draw boxplots of or.top.max genes
## save.wald              bool                If TRUE, save the DESeq2 object containing the results of the Wald test. This is FALSE by default, as the resulting object can be pretty big.
## color.palette          vec(color)          Vector of 3 colors used for the expression heatmap (lower values, middle, higher)
DE_test <- function(exp.mat = NULL, annot.df = NULL, design.df = NULL, assess.factor = NULL, assess.conti = NULL, adjp.max = 5E-02, lfc.min = .7, ihw = TRUE, lfcShrink = TRUE, enrp.max = 1E-02, enr.min.genes = 10, or.top.max = 100, outdir = getwd(), samples.dist.method = 'spearman', samples.hclust.method = 'ward.D', genes.dist.method = 'spearman', genes.hclust.method = 'ward.D', msigdb.do = c(TRUE, TRUE), do.do = c(TRUE, TRUE), go.do = c(TRUE, TRUE), kegg.do = c(TRUE, TRUE), wp.do = c(TRUE, TRUE), reactome.do = c(TRUE, TRUE), mesh.do = c(FALSE, FALSE), custom.do = c(FALSE, FALSE), custom_gmt_list = NULL, species = 'Homo sapiens', dotplot.maxterms = 50, my.seed = 1234L, boxplots = TRUE, save.wald = FALSE, heatmap.palette = c("royalblue3", "ivory", "orangered3"), BPPARAM = BiocParallel::SerialParam()) {
  
  if (tolower(species) == 'homo sapiens') {
    Org <- 'org.Hs'
  } else if (tolower(species) == 'mus musculus') {
    Org <- 'org.Mm'
  } else stop("Only 'Homo sapiens' and 'Mus musculus' species are supported !")
  
  ## Cleaning design
  for (x in seq_len(ncol(design.df))) design.df[,x] <- as.character(design.df[,x])
  design.df$Covar_colnames[design.df$Covar_colnames == ''] <- NA
  
  ## CHECKS
  ## Mandatory entries
  ### expression matrix
  if (is.null(exp.mat)) stop('An expression matrix is required !')
  if (!is.matrix(exp.mat)) stop('Expression data should be a matrix !')
  ### annotation
  if (is.null(annot.df)) stop('An annotation data.frame is required !')
  if (!is.data.frame(annot.df)) stop('Annotation data should be a data.frame !')
  ### design
  if (is.null(design.df)) stop('A design data.frame is required !')
  if (!is.data.frame(design.df)) stop('Design data should be a data.frame !')
  ## if exp.mat and annot.df have different size
  if (nrow(annot.df) != ncol(exp.mat)) stop("'exp.mat' and 'annot.df' do not have the same amount of samples!")
  ## if some annotation column names provided in design do not exist :
  ### samples :
  if (!all(unique(design.df$Samples_colname) %in% colnames(annot.df))) stop('All provided [Samples_colname] values should be in colnames(annot.df) !')
  ### covariates (outside design):
  #### Clean covariates names
  assess.factor <- gsub(pattern = "\\W", replacement = '.', x = assess.factor)
  if (!all(assess.factor %in% colnames(annot.df))) stop('All provided [assess.factor] values should be in colnames(annot.df) !')
  if (!all(assess.conti %in% colnames(annot.df))) stop('All provided [assess.conti] values should be in colnames(annot.df) !')
  ### covariates (from design):
  covars <- unique(unlist(lapply(seq_len(nrow(design.df)), function(x) unlist(strsplit(x = as.character(design.df$Covar_colnames[x]), split = ',')))))
  covars <- covars[!is.na(covars)]
  if(!all(is.na(covars))) {
    if (!all(covars[!is.na(covars)] %in% colnames(annot.df))) stop('All provided [Covar_colname] values should be in colnames(annot.df) !')
  }
  ### condition :
  if (!all(unique(design.df$Condition_colname) %in% colnames(annot.df))) stop('All provided [Condition_colname] values should be in colnames(annot.df) !')
  ## if samples are not identical
  # exp.mat <- exp.mat[,order(colnames(exp.mat))]
  # annot.df <- annot.df[order(annot.df[[samples.colname]]),]
  # if (!all(colnames(exp.mat) == annot.df[[samples.colname]])) stop(paste0("Content of the sample column '", samples.colname, "' is not identical to 'exp.mat' colnames !"))
  if (any(custom.do) & is.null(custom_gmt_list)) stop('GSEA/ORA on custom bank is requested, but no bank list (custom_gmt_list) provided !')
  if (!is.null(custom_gmt_list) & !is.list(custom_gmt_list)) stop('custom_gmt_list should be a named list of terms/genes data.frames as obtained from the clusterProfiler::read.gmt() function !')
  
  library(DESeq2)
  library(SummarizedExperiment)
  suppressPackageStartupMessages(library(ComplexHeatmap))
  suppressPackageStartupMessages(library(circlize))
  
  
  ## Looping on design entries
  for (cur.idx in seq_len(nrow(design.df))) {
    
    ## Limiting annot.df to required columns
    samples.colname <- design.df$Samples_colname[cur.idx]
    cur.cond <- design.df$Condition_colname[cur.idx]
    cur.covars <- unlist(strsplit(x = design.df$Covar_colnames[cur.idx], split = ','))
    cur.covars <- cur.covars[!is.na(cur.covars)]
    cur.condA <- unlist(strsplit(x = design.df$Condition_A[cur.idx], split = ','))
    cur.condB <- unlist(strsplit(x = design.df$Condition_B[cur.idx], split = ','))
    cur.annot.df <- annot.df[, colnames(annot.df) %in% c(samples.colname, cur.covars, cur.cond)]
    cur.name <- design.df$Comparison_name[cur.idx]
    cur.exp.mat <- exp.mat
    cur.annot.df <- annot.df
    
    
    ## Filtering special characters in cur.cond
    colnames(cur.annot.df) <- gsub(pattern = "\\W", replacement = '.', x = colnames(cur.annot.df))
    # message(paste(levels(cur.annot.df[[cur.cond]]), collapse = ' ; '))
    levels(cur.annot.df[[cur.cond]]) <- gsub(pattern = "\\W", replacement = '.', x = levels(cur.annot.df[[cur.cond]]))
    # message(paste(levels(cur.annot.df[[cur.cond]]), collapse = ' ; '))
    
    
    ## Adjusting the datasets if needed
    ## Handling NAs in current annotation
    na.check <- is.na(cur.annot.df[[cur.cond]])
    if (any(na.check)) {
      cur.exp.mat <- cur.exp.mat[,!na.check]
      cur.annot.df <- cur.annot.df[!na.check,]
    }
    ## Handling requested levels
    lev.checks <- cur.annot.df[[cur.cond]] %in% c(cur.condA, cur.condB)
    if (!all(lev.checks)) {
      cur.exp.mat <- cur.exp.mat[,lev.checks]
      cur.annot.df <- cur.annot.df[lev.checks,]
    }
    
    ## Forcing a relevel (if some levels were lost)
    # cur.annot.df[[cur.cond]] <- as.factor(as.character(cur.annot.df[[cur.cond]]))
    # levtab <- as.data.frame(table(cur.annot.df[[cur.cond]]), stringsAsFactors = FALSE)
    # levtab <- levtab[order(levtab$Var1),]
    # levtab <- levtab[levtab$Freq > 0,]
    # cur.annot.df[[cur.cond]] <- as.factor(as.character(cur.annot.df[[cur.cond]]))
    # myref <- levels(cur.annot.df[[cur.cond]])[1]
    # cur.annot.df[[cur.cond]] <- relevel(cur.annot.df[[cur.cond]], ref = myref)
    cur.annot.df[[cur.cond]] <- droplevels(cur.annot.df[[cur.cond]])
    
    
    ## Creating design (factor then Batch, w/o intercept)
    my.textform <- paste(c('~0', unique(c(cur.cond, cur.covars))), collapse = '+')
    # my.textform <- paste(c('~0', unique(c(cur.covars, cur.cond))), collapse = '+')
    # my.textform <- paste0('~', paste(unique(c(cur.covars, cur.cond)), collapse = '+'))
    # my.textform <- paste0('~', paste(unique(c(cur.cond, cur.covars)), collapse = '+'))
    # my.textform <- paste(c('~0', unique(c(cur.cond, cur.covars))), collapse = '+')
    my.design <- as.formula(my.textform)
    
    ## Creating the main output dir
    fac.dir <- paste0(outdir, '/Differential_analysis')
    factor.dir <- paste(c(fac.dir, paste0('adjp.', adjp.max, '_lfc.', lfc.min), my.textform), collapse = '/')
    # dir.create(path = factor.dir, recursive = TRUE)
    de.dir <- paste(c(factor.dir, cur.name), collapse = '/')
    dir.create(path = de.dir, recursive = TRUE)
    
    ## Creating the DESeq2 object
    suppressMessages(DE2obj <- DESeq2::DESeqDataSetFromMatrix(countData = cur.exp.mat, colData = cur.annot.df, design = my.design))
    rm(cur.exp.mat, cur.annot.df)
    
    ## Saving the DESeq object
    # saveRDS(object = DE2obj, file = paste0(factor.dir, '/', cur.cond, '_rawcounts.RDS'), compress = 'bzip2')
    saveRDS(object = DE2obj, file = paste0(de.dir, '/', cur.cond, '_rawcounts.RDS'), compress = 'bzip2')
    
    ## Normalizing by vst (for PCA & heatmap)
    DE2obj.norm <- DESeq2::vst(object = DE2obj, blind = TRUE)
    norm.mat <- SummarizedExperiment::assay(DE2obj.norm)
    ## Save VST matrix 
    write.table(x = data.frame(Feature = rownames(norm.mat), norm.mat, check.names = FALSE), file = gzfile(paste0(de.dir, '/Normalized.vst_matrix.tsv.gz')), sep = '\t', quote = FALSE, row.names = FALSE)
    
    ## Assessing DESIGN covariates, and regressing if requested
    if (length(cur.covars) > 0) {
      ### Assessing covariates
      #### Splitting factor and continuous covariates
      factor.colnames <- conti.colnames <- NULL
      for (cn in cur.covars) if (is.factor(DE2obj@colData[[cn]])) factor.colnames <- c(factor.colnames, cn) else if (is.numeric(DE2obj@colData[[cn]])) conti.colnames <- c(conti.colnames, cn) else stop(paste0('Covariate [', cn, '] is neither a factor nor a numeric/integer vector !'))
      #### Assessing covariates
      assess_covar(mat = norm.mat, annot.df = as.data.frame(DE2obj@colData), factor.names = c(cur.cond, factor.colnames), conti.names = conti.colnames, red.method = 'pca', ndim.max = round(ncol(norm.mat)/2), center = TRUE, scale = TRUE, out.file = paste0(de.dir, '/', cur.cond, '_assess_covariates_01_unregressed.png'))
      #### Running limma::removeBatchEffect the good way
      limma.bc.batch2 <- limma.bc.batch1 <- limma.bc.covar <- NULL
      ##### Handling factor covariates
      for (fc in factor.colnames) {
        message(paste0('ASSESS COVAR FACTOR COVAR : ', fc))
        if (is.null(limma.bc.batch1)) {
          limma.bc.batch1 <- DE2obj@colData[[fc]]
        } else if (is.null(limma.bc.batch2)) {
          limma.bc.batch2 <- DE2obj@colData[[fc]]
        } else message(paste0('Factor [', fc, '] will not be considered for matrix regression by limma::removeBatchEffect as ony 2 factors can be used.'))
      }
      ##### Handling continuous covariates
      for (cc in conti.colnames) {
        message(paste0('ASSESS COVAR CONTI COVAR : ', cc))
        if (is.null(limma.bc.covar)) limma.bc.covar <- as.matrix(DE2obj@colData[, cc, drop = FALSE]) else limma.bc.covar <- cbind(limma.bc.covar, as.matrix(DE2obj@colData[, cc, drop = FALSE]))
      }
      
      #### Testing if design matrix is full-rank
      test.batch <- limma.bc.batch1
      test.batch2 <- limma.bc.batch2
      test.covariates <- limma.bc.covar
      test.design = model.matrix(as.formula(paste0('~0+', cur.cond)), data = DE2obj@colData)
      if (!is.null(test.batch)) {
        test.batch <- as.factor(test.batch)
        contrasts(test.batch) <- contr.sum(levels(test.batch))
        test.batch <- model.matrix(~test.batch)[, -1, drop = FALSE]
      }
      if (!is.null(test.batch2)) {
        test.batch2 <- as.factor(test.batch2)
        contrasts(test.batch2) <- contr.sum(levels(test.batch2))
        test.batch2 <- model.matrix(~test.batch2)[, -1, drop = FALSE]
      }
      if (!is.null(test.covariates)) test.covariates <- as.matrix(test.covariates)
      X.batch <- cbind(test.batch, test.batch2, test.covariates)
      test.designX = as.matrix(cbind(test.design, X.batch))
      ne <- limma::nonEstimable(test.designX)
      rm(test.batch, test.batch2, test.covariates, X.batch, test.designX)
      
      if(!is.null(ne)) {
        message(paste(ne, collapse = ', '))
        ## Matrix is NOT full-rank, NO regression !
        message("Can't estimate ", fc, ' as design matrix is not full-rank !')
        # print(paste0("Can't estimate ", fc, ' as design matrix is not full-rank !'))
      } else {
        ## Matrix is full-rank, one can regress !
        ber_method <- 'limma'
        # if (is.null(limma.bc.batch2) & is.null(limma.bc.covar)) {
        #   ## If only ONE CATEGORIAL covariate, use sva::ComBat
        #   ber_method <- 'ComBat'
        #   norm.mat <- sva::ComBat(dat = norm.mat, batch = limma.bc.batch1, mod = model.matrix(as.formula(paste0('~', cur.cond)), data = SummarizedExperiment::colData(DE2obj)), BPPARAM = BPPARAM)
        # } else {
          ## Else use limma::removeBatchEffect
          norm.mat <- limma::removeBatchEffect(x = norm.mat, batch = limma.bc.batch1, batch2 = limma.bc.batch2, covariates = limma.bc.covar, design = model.matrix(as.formula(paste0('~0+', cur.cond)), data = SummarizedExperiment::colData(DE2obj)))
        # }
        ## Save BER matrix 
        write.table(x = data.frame(Feature = rownames(norm.mat), norm.mat, check.names = FALSE), file = gzfile(paste0(de.dir, '/Normalized.vst.BER.', ber_method, '_matrix.tsv.gz')), sep = '\t', quote = FALSE, row.names = FALSE)
        
        ### Assessing covariates (after regression)
        assess_covar(mat = norm.mat, annot.df = as.data.frame(DE2obj@colData), factor.names = c(cur.cond, factor.colnames), conti.names = conti.colnames, red.method = 'pca', ndim.max = round(ncol(norm.mat)/2), center = TRUE, scale = TRUE, out.file = paste0(de.dir, '/', cur.cond, '_assess_covariates_02_regressed.png'))
      }
    }
    
    ### PCAs for DESIGN covariates
    library(ggfortify)
    for (p in c(cur.cond, cur.covars)) {
      # png(filename = paste0(factor.dir, '/PCA_vst_', p, '.png'), width = 1100, height = 1000)
      png(filename = paste0(de.dir, '/PCA_vst_', p, '.png'), width = 1100, height = 1000)
      try(print(ggplot2::autoplot(prcomp(t(norm.mat)), data = as.data.frame(SummarizedExperiment::colData(DE2obj)), colour = p, size = 3)), silent = TRUE)
      dev.off()
    }
    
    ## Assessing TEST covariates, and regressing if requested
    if (any(!is.null(c(assess.factor, assess.conti)))) {
      test.mat <- SummarizedExperiment::assay(DE2obj.norm)
      test.dir <- paste0(de.dir, '/Test_covariates')
      dir.create(test.dir)
      
      tmp.annot <- as.data.frame(SummarizedExperiment::colData(DE2obj))
      ### plot PCA of normalized,unregressed data colored by TEST covariates
      Utest.dir <- paste0(test.dir, '/PCA_UNREGRESSED')
      dir.create(path = Utest.dir)
      for (p in unique(c(cur.cond, assess.factor, assess.conti))) {
        png(filename = paste0(Utest.dir, '/PCA_vst_UNREGRESSED_col.', p, '.png'), width = 1100, height = 1000)
        library(ggfortify)
        try(print(ggplot2::autoplot(prcomp(t(test.mat)), data = tmp.annot, colour = p, size = 3)), silent = TRUE)
        dev.off()
      }
      
      Atest.dir <- paste0(test.dir, '/ASSESS_MAP')
      dir.create(path = Atest.dir)
      
      ### Plotting UNREGRESSED assessment heatmap
      assess_covar(mat = test.mat, annot.df = tmp.annot, factor.names = c(cur.cond, assess.factor), conti.names = assess.conti, red.method = 'pca', ndim.max = round(ncol(test.mat)/2), center = TRUE, scale = TRUE, out.file = paste0(Atest.dir, '/', cur.cond, '_TEST_covariates_01_unregressed.png'))
      
      Rtest.dir <- paste0(test.dir, '/PCA_REGRESSED')
      dir.create(path = Rtest.dir)
      
      #### 1) Handling CONTINUOUS covariates
      for (cc in assess.conti) {
        message(paste0('ASSESS COVAR UNREGRESSED CONTI COVAR : ', cc))
        
        #### Testing if design matrix is full-rank
        test.covariates <- tmp.annot[[cc]]
        test.design = model.matrix(as.formula(paste0('~0+', cur.cond)), data = DE2obj@colData)
        test.covariates <- as.matrix(test.covariates)
        test.designX = as.matrix(cbind(test.design, test.covariates))
        ne <- limma::nonEstimable(test.designX)
        rm(test.covariates, test.designX)
        
        if(!is.null(ne)) {
          message(paste(ne, collapse = ', '))
          ## Matrix is NOT full-rank, NO regression !
          message("Can't estimate ", cc, ' as design matrix is not full-rank !')
          # print(paste0("Can't estimate ", cc, ' as design matrix is not full-rank !'))
        } else {
          ## Regressing the continuous covariate
          ber.try <- try(tmp.mat <- limma::removeBatchEffect(x = test.mat, batch = NULL, batch2 = NULL, covariates = tmp.annot[[cc]], design = model.matrix(as.formula(paste0('~0+', cur.cond)), data = DE2obj.norm@colData)), silent = TRUE)
          if (!is(ber.try, class2 = 'try-error')) {
            ## Plotting REGRESSED assessment heatmap
            assess_covar(mat = tmp.mat, annot.df = as.data.frame(DE2obj@colData), factor.names = c(cur.cond, assess.factor), conti.names = assess.conti, red.method = 'pca', ndim.max = round(ncol(tmp.mat)/2), center = TRUE, scale = TRUE, out.file = paste0(Atest.dir, '/', cur.cond, '_TEST_covariates_02_REGRESSED_', cc, '.png'))
            ### plot PCA of REGRESSED data colored by cur.cond
            png(filename = paste0(Rtest.dir, '/PCA_vst_REGRESSED.limma.', cc, '_col.', cur.cond, '.png'), width = 1100, height = 1000)
            library(ggfortify)
            try(print(ggplot2::autoplot(prcomp(t(tmp.mat)), data = as.data.frame(SummarizedExperiment::colData(DE2obj)), colour = cur.cond, size = 3)), silent = TRUE)
            dev.off()
          }
        }
      }
      
      #### 2) Handling CATEGORICAL (FACTOR) covariates
      for (fc in assess.factor) {
        message(paste0('ASSESS COVAR UNREGRESSED FACTOR COVAR : ', fc))
        
        #### Testing if design matrix is full-rank
        test.batch <- tmp.annot[[fc]]
        test.design = model.matrix(as.formula(paste0('~0+', cur.cond)), data = DE2obj@colData)
        test.batch <- as.factor(test.batch)
        if(nlevels(test.batch) < 2) {
          message("Can't estimate ", fc, ' as it only has one level !')
          # print(paste0("Can't estimate ", fc, ' as it only has one level !'))
        } else {
          contrasts(test.batch) <- contr.sum(levels(test.batch))
          test.batch <- model.matrix(~test.batch)[, -1, drop = FALSE]
          # print(' test.batch')
          # print(str(test.batch))
          # print(' test.design')
          # print(nrow(test.design))
          ## Handling NA batches
          # if(!all(dim(test.batch) == dim(test.design))) {
          if (!nrow(test.batch) == nrow(test.design)) {
            message("Can't estimate ", fc, " as it doesn't have the same size as the evaluated comparison (due to NAs) !")
            # print(paste0("Can't estimate ", fc, " as it doesn't have the same size as the evaluated comparison (due to NAs) !"))
          } else {
            test.designX = as.matrix(cbind(test.design, test.batch))
            ne <- limma::nonEstimable(test.designX)
            rm(test.batch, test.designX)
            
            if(!is.null(ne)) {
              message(paste(ne, collapse = ', '))
              ## Matrix is NOT full-rank, NO regression !
              message("Can't estimate ", fc, ' as design matrix is not full-rank !')
              # print(paste0("Can't estimate ", fc, ' as design matrix is not full-rank !'))
            } else {
              ## Matrix is full-rank, one can regress !
              ## Regressing
              ber.try <- try(tmp.mat <- limma::removeBatchEffect(x = test.mat, batch = tmp.annot[[fc]], batch2 = NULL, covariates = NULL, design = model.matrix(as.formula(paste0('~0+', cur.cond)), data = SummarizedExperiment::colData(DE2obj@colData))), silent = TRUE)
              # ber.try <- try(tmp.mat <- sva::ComBat(dat = test.mat, batch = tmp.annot[[fc]], mod = model.matrix(as.formula(paste0('~', cur.cond)), data = SummarizedExperiment::colData(DE2obj)), BPPARAM = BPPARAM), silent = TRUE)
              if (!is(ber.try, class2 = 'try-error')) {
                ## Plotting REGRESSED assessment heatmap
                assess_covar(mat = tmp.mat, annot.df = tmp.annot, factor.names = c(cur.cond, assess.factor), conti.names = assess.conti, red.method = 'pca', ndim.max = round(ncol(tmp.mat)/2), center = TRUE, scale = TRUE, out.file = paste0(Atest.dir, '/', cur.cond, '_TEST_covariates_02_REGRESSED_', fc, '.png'))
                ### plot PCA of REGRESSED data colored by cur.cond
                png(filename = paste0(Rtest.dir, '/PCA_vst_REGRESSED.limma.', fc, '_col.', cur.cond, '.png'), width = 1100, height = 1000)
                library(ggfortify)
                try(print(ggplot2::autoplot(prcomp(t(tmp.mat)), data = tmp.annot, colour = cur.cond, size = 3)), silent = TRUE)
                dev.off()
              }
            }
          }
        }
      }
    }
    
    ## Remove temporary VST object
    rm(DE2obj.norm)
    
    ## Performing the DE test
    set.seed(my_seed)
    htg.de.wald <- DESeq2::DESeq(DE2obj)
    
    ## Saving the Wald test DESeq object
    # if(save.wald) saveRDS(object = htg.de.wald, file = paste0(factor.dir, '/', cur.cond, '_wald.RDS'), compress = 'bzip2')
    if(save.wald) saveRDS(object = htg.de.wald, file = paste0(de.dir, '/', cur.cond, '_wald.RDS'), compress = 'bzip2')
    
    ## Creating output dir
    mycoef <- paste0(cur.cond, ' : ', paste(cur.condA, collapse='+'), ' -vs- ', paste(cur.condB, collapse='+'))
    message(mycoef)
    message(cur.name)

    # de.dir <- paste(c(factor.dir, cur.name), collapse = '/')
    # dir.create(path = de.dir, recursive = TRUE)

    ## Getting results table for current contrast
    # mycontrast <- sapply(all.combz[[mycomb]], function(x) { paste0(cur.cond, x)}, simplify = FALSE)
    # mycontrast <- list(cur.condA, cur.condB)
    mycontrast <- list(paste0(cur.cond, cur.condA), paste0(cur.cond, cur.condB))
    # myvalues <- c(rep(1/length(cur.condA), length(cur.condA)), rep(-1/length(cur.condB), length(cur.condB)))
    myvalues <- c(1, -1/length(cur.condB))
    if (ihw) {
      set.seed(my_seed)
      DEres <- DESeq2::results(htg.de.wald, contrast = mycontrast, listValues = myvalues, independentFiltering = TRUE, alpha = adjp.max, pAdjustMethod = "BH", parallel = TRUE, BPPARAM = BPPARAM, filterFun = IHW::ihw)
    } else {
        DESeq2::results(htg.de.wald, contrast = mycontrast, listValues = myvalues, independentFiltering = TRUE, alpha = adjp.max, pAdjustMethod = "BH", parallel = TRUE, BPPARAM = BPPARAM)
    }
    ## Saving the test results object
    saveRDS(object = DEres, file = paste0(de.dir, '/', cur.name, '_results.RDS'), compress = 'bzip2')
    
    ## Shrinking l2fc
    if (lfcShrink) {
      set.seed(my_seed)
      suppressMessages(DEres <- DESeq2::lfcShrink(htg.de.wald, contrast = mycontrast, type = 'ashr', res = DEres))
      ## Saving the test reults object
      saveRDS(object = DEres, file = paste0(de.dir, '/', cur.name, '_results_lfcShrink.RDS'), compress = 'bzip2')
    }
    # rm(htg.de.wald)
    
    ## Histogram of P-values
    png(paste0(de.dir, '/', cur.name, '_phist.png'), width = 2048, height = 768)
    par <- par(mfrow = c(1, 2))
    hist(DEres$pvalue, col = "lightblue", main = paste0("Histogram of raw P-values (DESeq2)\n", mycoef), breaks = 100, xlim = c(0,1), xlab = "P-value")
    hist(DEres$padj, col = "lightblue", main = paste0("Histogram of BH-adjusted P-values (DESeq2)\n", mycoef), breaks = 100, xlim = c(0,1), xlab = "P-value")
    abline(v = adjp.max, col = 2, lty = 2)
    dev.off()
    
    ## MAplot
    png(paste0(de.dir, '/', cur.name, '_MA.png'), width = 1024, height = 768)
    DESeq2::plotMA(DEres, alpha = adjp.max, main = paste0("M-A Plot\n", mycoef), cex = 1)
    dev.off()
    
    ## Volcano plot
    deg.idx <- DEres$padj <= adjp.max & abs(DEres$log2FoldChange) >= lfc.min
    png(paste0(de.dir, '/', cur.name, '_volcano.png'), width = 1024, height = 768)
    plot(x = DEres$log2FoldChange, y = -log10(DEres$padj), xlab = "log2(Fold-Change)", ylab = "-log10(adjusted P-value)", col = ifelse(deg.idx, "red", "black"), main = paste0("Volcano plot\n", mycoef), pch = 20)
    grid()
    abline(h = -log10(adjp.max), lty = 2, col = 4)
    abline(v = lfc.min * c(-1, 1), lty = 2, col = 4)
    dev.off()
    
    ## Computing per-class metrics
    mc.samp.idx <- lapply(levels(SummarizedExperiment::colData(DE2obj)[[cur.cond]]), function(mc.lev) {
      which(SummarizedExperiment::colData(DE2obj)[[cur.cond]] == mc.lev)
    })
    names(mc.samp.idx) <- levels(SummarizedExperiment::colData(DE2obj)[[cur.cond]])
    mc.metrics <- lapply(names(mc.samp.idx), function(mc.lev) {
      mydf <- data.frame(N = length(mc.samp.idx[[mc.lev]])
                         , Min = rowMins(norm.mat[,mc.samp.idx[[mc.lev]]], dims = 1)
                         , Max = rowMaxs(norm.mat[,mc.samp.idx[[mc.lev]]], dims = 1)
                         , Mean = rowMeans(norm.mat[,mc.samp.idx[[mc.lev]]], dims = 1)
                         , Median = matrixStats::rowMedians(x = norm.mat, cols = mc.samp.idx[[mc.lev]])
                         , matrixStats::rowQuantiles(x = norm.mat, cols = mc.samp.idx[[mc.lev]], probs = c(.25, .75)))
      colnames(mydf) <- paste0(mc.lev, '.', c(colnames(mydf)[1:(ncol(mydf)-2)], 'Q25', 'Q75'))
      return(mydf)
    })
    ## Output table
    DEres.df <- cbind(Symbol = rownames(DEres), as.data.frame(DEres), Reduce(f = cbind, x = mc.metrics))
    sig.word <- paste0('Sig_@adjp', adjp.max, '_lfc', lfc.min)
    DEres.df[[sig.word]] <- 0
    DEres.df[[sig.word]][deg.idx] <- 1
    DEres.df <- DEres.df[order(DEres.df$padj, abs(DEres.df$log2FoldChange), decreasing = c(FALSE, TRUE)),]
    write.table(DEres.df, file = gzfile(paste0(de.dir, '/', cur.name, '_results.tsv.gz')), sep = '\t', quote = FALSE, row.names = FALSE)
    
    sig.genes <- as.character(DEres.df$Symbol[DEres.df[sig.word] == 1])
    
    ## Draw gene boxplot
    if(boxplots & length(sig.genes) > 0) {
      gdir <- paste0(de.dir, '/boxplots')
      dir.create(path = gdir, recursive = TRUE)
      for (g in sig.genes[1:(min(length(sig.genes), or.top.max))]) {
        png(filename = paste0(gdir, '/', g, '_norm.exp_boxplot.png'), width = 800, height = 600)
        sig.split <- split(norm.mat[g, ], droplevels(SummarizedExperiment::colData(DE2obj)[[cur.cond]]))
        boxplot2l(x = sig.split, col = seq_along(sig.split), main = paste0(g, ' normalized expression VS ', cur.cond, '\nDESeq2 : l2FC = ', round(DEres.df[g, 'log2FoldChange'], digits = 3), ' ; adjP = ', format(DEres.df[g, 'padj'], scientific = TRUE, digits = 3)), xlab = '', ylab = 'Normalized expression', vertical = TRUE, cex = 2)
        
        dev.off()
      }
    }
    
    ## Setting a color palette for the heatmaps
    myRamp <- circlize::colorRamp2(c(-2, 0, 2), heatmap.palette)
      
    if (length(sig.genes) > enr.min.genes) {
      
      cur.annot <- as.data.frame(SummarizedExperiment::colData(DE2obj)[,c(cur.cond, cur.covars), drop = FALSE])
      # cur.samples.idx <- cur.annot[[cur.cond]] %in% unlist(all.combz[[mycomb]])
      
      ## Heatmap
      ## data to plot
      # plotDat <- norm.mat[rownames(norm.mat) %in% sig.genes, cur.samples.idx]
      plotDat <- norm.mat[rownames(norm.mat) %in% sig.genes,]
      # plotDat <- norm.mat[rownames(norm.mat) %in% sig.genes, SummarizedExperiment::colData(DE2obj)[[cur.cond]] %in% unlist(all.combz[[mycomb]])]
      z.mat <- (plotDat - rowMeans(plotDat)) / matrixStats::rowSds(plotDat)
      # Creating sample annotation
      # ha1 = ComplexHeatmap::HeatmapAnnotation(df = SummarizedExperiment::colData(DE2obj)[,c(cur.cond, covar.colnames), drop = FALSE][SummarizedExperiment::colData(DE2obj)[[cur.cond]] %in% unlist(all.combz[[mycomb]]),])
      
      set.seed(1)
      # ha1 = ComplexHeatmap::HeatmapAnnotation(df = cur.annot[cur.samples.idx,c(cur.cond, cur.covars), drop = FALSE])
      ha1 = ComplexHeatmap::HeatmapAnnotation(df = cur.annot[,c(cur.cond, cur.covars), drop = FALSE])
      
      ## Looping through requested clustering methods
      for (sdm in samples.dist.method) {
        for (shm in samples.hclust.method) {
          for (gdm in genes.dist.method) {
            for (ghm in genes.hclust.method) {
              ## Clustering samples
              hc.s <- hclust(amap::Dist(x = t(plotDat), method = sdm), method = shm)
              ## Clustering genes
              hc.g <- hclust(amap::Dist(x = plotDat, method = gdm), method = ghm)
              ## Compute heatmap
              set.seed(my.seed)
              myHM <- suppressMessages(ComplexHeatmap::Heatmap(z.mat, name = "Normalized counts"
                                                               # use my custom color palette
                                                               , col = myRamp
                                                               # do not show gene names
                                                               , show_row_name = TRUE
                                                               # do not clusterize samples
                                                               , cluster_columns = hc.s
                                                               , cluster_rows = hc.g
                                                               # add a nice grey border to cells
                                                               , rect_gp = grid::gpar(col = "darkgrey", lwd=0.5)
                                                               # add sample annotation
                                                               , top_annotation = ha1
                                                               , use_raster = TRUE
                                                               , raster_device = 'png'
                                                               ))
              ## Draw heatmap
              png(paste0(de.dir, '/', cur.name, '_sig.', nrow(z.mat), 'x', ncol(z.mat), '_', paste(c(gdm, ghm, sdm, shm), collapse = "_"), '.heatmap.png'), width = max(min(ncol(z.mat) * 15, 2000), 600) + 200, height = min(length(sig.genes) * 10, 5000) + 300)
              ComplexHeatmap::draw(myHM)
              dev.off()
            }
          }
        }
      }
    }
  
    ## Shorter heatmap if more sig genes than requested "topN"
    if(length(sig.genes) > or.top.max) {
      
      ## Heatmap
      ## data to plot
      sig.genes <- as.character(DEres.df$Symbol[DEres.df[[sig.word]] == 1][1:or.top.max])
      # sig.genes <- as.character(DEres.df$Symbol[DEres.df$cuts.in == 1][1:or.top.max])
      # plotDat <- norm.mat[rownames(norm.mat) %in% sig.genes, cur.samples.idx]
      plotDat <- norm.mat[rownames(norm.mat) %in% sig.genes,]
      # plotDat <- norm.mat[rownames(norm.mat) %in% sig.genes, SummarizedExperiment::colData(DE2obj)[[cur.cond]] %in% unlist(all.combz[[mycomb]])]
      z.mat <- (plotDat - rowMeans(plotDat)) / matrixStats::rowSds(plotDat)
      # Creating sample annotation
      # ha1 = ComplexHeatmap::HeatmapAnnotation(df = SummarizedExperiment::colData(DE2obj)[,c(cur.cond, covar.colnames)][annot.df[[cur.cond]] %in% unlist(all.combz[[mycomb]]),])
      set.seed(1)
      # ha1 = ComplexHeatmap::HeatmapAnnotation(df = cur.annot[cur.samples.idx,c(cur.cond, cur.covars), drop = FALSE])
      ha1 = ComplexHeatmap::HeatmapAnnotation(df = cur.annot[,c(cur.cond, cur.covars), drop = FALSE])
      ## Clustering samples
      for (sdm in samples.dist.method) {
        for (shm in samples.hclust.method) {
          for (gdm in genes.dist.method) {
            for (ghm in genes.hclust.method) {
              hc.s <- hclust(amap::Dist(x = t(plotDat), method = sdm), method = shm)
              ## Clustering genes
              hc.g <- hclust(amap::Dist(x = plotDat, method = gdm), method = ghm)
              ## Computing heatmap
              myHM <- suppressMessages(ComplexHeatmap::Heatmap(z.mat, name = "Normalized counts",
                                                             col = myRamp,
                                                             show_row_name = TRUE,
                                                             cluster_columns = hc.s,
                                                             cluster_rows = hc.g,
                                                             rect_gp = grid::gpar(col = "darkgrey", lwd=0.5),
                                                             top_annotation = ha1))
              ## Draw
              png(paste0(de.dir, '/', cur.name, '_sig.TOP', nrow(z.mat), 'x', ncol(z.mat), '_', paste(c(gdm, ghm, sdm, shm), collapse = "_"), '.heatmap.png'), width = max(min(ncol(z.mat) * 15, 2000), 600) + 200, height = min(length(sig.genes) * 10, 5000) + 300)
              ComplexHeatmap::draw(myHM)
              dev.off()
            }
          }
        }
      }
    }
  
    ## Functional enrichment
    if (any(unlist(msigdb.do), kegg.do, do.do, go.do, wp.do, reactome.do, mesh.do) & length(which(deg.idx)) >= enr.min.genes & !is.null(species)) {
        
        enr.inputs <- table2enr(deseq2.res.data = DEres.df, species = species, geneid.colname = 'Symbol', geneid.type = 'SYMBOL', value.colname = 'log2FoldChange', topN.max = or.top.max, topN.order.colname = 'padj', topN.order.decreasing = FALSE, topN.cutoff = enrp.max, topN.keep.operator = '<')
        
        ## MSIGDB
        if (any(unlist(msigdb.do))) {
          ### Get collections
          msigdb.collec <- as.data.frame(msigdbr::msigdbr_collections())
          ### Add a tag to cross with provided msigdb.do names
          msigdb.collec$tag <- paste(msigdb.collec$gs_cat, msigdb.collec$gs_subcat, sep = '.')
          msigdb.collec$tag <- sub(pattern = '\\.$', replacement = '', x = msigdb.collec$tag)
          ### Restrict to requested names
          if (is.list(msigdb.do)) {
            msigdb.collec <- msigdb.collec[msigdb.collec$tag %in% names(msigdb.do),]
          } else if (length(msigdb.do) == 2 & all(is.logical(msigdb.do))) {
            msigdb.do <- lapply(msigdb.collec$tag, function(x) { return(msigdb.do) })
            names(msigdb.do) <- msigdb.collec$tag
          }
          ### Loop on collections
          for (mc in msigdb.collec$tag) {
            msc <- if(msigdb.collec[msigdb.collec$tag == mc,2] == '') msigdb.collec[msigdb.collec$tag == mc,1] else paste(c(msigdb.collec[msigdb.collec$tag == mc,1], msigdb.collec[msigdb.collec$tag == mc,2]), collapse = '_')
            ## Import the TERM2GENE object corresponding to the desired category/subcategory combo
            my.t2g <- msigdb_to_t2g(species = species, category = msigdb.collec[msigdb.collec$tag == mc,1], subcategory = msigdb.collec[msigdb.collec$tag == mc,2])
            ### GSEA
            if (msigdb.do[[mc]][1]) {
              my.gsea.res <- try(gsea.run(geneList = enr.inputs$gsea.genevec, species = species, func.name = 'clusterProfiler::GSEA', t2g = my.t2g, t2g.name = msc, gene2Symbol = enr.inputs$gene2Symbol, seed = my.seed, pvalueCutoff = enrp.max, minGSSize = enr.min.genes))
              ## Generate plots / outputs
              if (!is(my.gsea.res, class2 = 'try-error')) gsea.output(gseaResult = my.gsea.res, out.dir = de.dir, comp.name = cur.name)
            }
            ### ORA
            if(msigdb.do[[mc]][2]) {
              my.ora.res <- try(ora.run(gene = enr.inputs$ora.genevec, universe = unname(enr.inputs$gene2Symbol), species = species, func.name = 'clusterProfiler::enricher', t2g = my.t2g, t2g.name = msc, gene2Symbol = enr.inputs$gene2Symbol, pvalueCutoff = enrp.max, minGSSize = enr.min.genes))
              ## Generate plots / outputs
              if (!is(my.ora.res, class2 = 'try-error')) ora.output(enrichResult = my.ora.res, out.dir = de.dir, comp.name = cur.name, geneList = enr.inputs$gsea.genevec)
            }
          }
        }
        
        ## GO (gene ontology)
        if (any(go.do)) {
          ### GSEA
          if(go.do[1]) {
            func.name <- 'clusterProfiler::gseGO'
            for (x in c('BP', 'CC', 'MF')) {
              my.org <- paste0(msigdbr2org(species), '.db')
              library(my.org, character.only = TRUE)
              my.gsea.res <- try(gsea.run(geneList = enr.inputs$gsea.genevec, species = species, func.name = func.name, t2g = NULL, t2g.name = NULL, gene2Symbol = enr.inputs$gene2Symbol, seed = my.seed, pvalueCutoff = enrp.max, minGSSize = enr.min.genes, OrgDb = get(my.org), ont = x))
              if (!is(my.gsea.res, class2 = 'try-error')) {
                my.gsea.res@setType <- paste(c(my.gsea.res@setType, x), collapse = '_')
                gsea.output(gseaResult = my.gsea.res, out.dir = de.dir, comp.name = cur.name)
                ## Simplify
                if(nrow(my.gsea.res) > 1) {
                  my.gsea.res@setType <- x
                  my.gsea.res <- enrichplot::pairwise_termsim(my.gsea.res)
                  my.gsea.res.simp <- clusterProfiler::simplify(my.gsea.res, cutoff = 0.7, by = "p.adjust", select_fun = min)
                  if(nrow(my.gsea.res.simp) < nrow(my.gsea.res)) {
                    my.gsea.res.simp@setType <- paste(c(func.name, x, 'simplified'), collapse = '_')
                    gsea.output(gseaResult = my.gsea.res.simp, out.dir = de.dir, comp.name = cur.name)
                  }
                }
              }
            }
          }
          ### ORA
          if(go.do[2]) {
            func.name <- 'clusterProfiler::enrichGO'
            for (x in c('BP', 'CC', 'MF')) {
              my.org <- paste0(msigdbr2org(species), '.db')
              library(my.org, character.only = TRUE)
              my.ora.res <- ora.run(gene = enr.inputs$ora.genevec, species = species, func.name = func.name, t2g = NULL, t2g.name = NULL, gene2Symbol = enr.inputs$gene2Symbol, pvalueCutoff = enrp.max, minGSSize = enr.min.genes, OrgDb = get(my.org), ont = x)
              if (!is(my.ora.res, class2 = 'try-error')) {
                my.ora.res@ontology <- paste(c(my.ora.res@ontology, x), collapse = '_')
                ora.output(enrichResult = my.ora.res, out.dir = de.dir, comp.name = cur.name, geneList = enr.inputs$gsea.genevec)
                ## Simplify
                if(nrow(my.ora.res) > 1) {
                  my.ora.res@ontology <- x
                  my.ora.res <- enrichplot::pairwise_termsim(my.ora.res)
                  my.ora.res.simp <- clusterProfiler::simplify(my.ora.res, cutoff = 0.7, by = "p.adjust", select_fun = min)
                  if(nrow(my.ora.res.simp) < nrow(my.ora.res)) {
                    my.ora.res.simp@ontology <- paste(c(func.name, x, 'simplified'), collapse = '_')
                    ora.output(enrichResult = my.ora.res.simp, out.dir = de.dir, comp.name = cur.name, geneList = enr.inputs$gsea.genevec)
                  }
                }
              }
            }
          }
        }
        
        ## DO (disease ontology)
        if (any(do.do)) {
          ### GSEA
          if (do.do[1]) {
            for (x in c('DOSE::gseDO', 'DOSE::gseNCG', 'DOSE::gseDGN')) {
              my.gsea.res <- try(gsea.run(geneList = enr.inputs$gsea.genevec, species = species, func.name = x, t2g = NULL, t2g.name = NULL, gene2Symbol = enr.inputs$gene2Symbol, seed = my.seed, pvalueCutoff = enrp.max, minGSSize = enr.min.genes))
              if (!is(my.gsea.res, class2 = 'try-error')) gsea.output(gseaResult = my.gsea.res, out.dir = de.dir, comp.name = cur.name)
            }
            ### ORA
            if(do.do[2]) {
              for (x in c('DOSE::enrichDO', 'DOSE::enrichNCG', 'DOSE::enrichDGN')) {
                my.ora.res <- try(ora.run(gene = enr.inputs$ora.genevec, species = species, func.name = x, t2g = NULL, t2g.name = NULL, gene2Symbol = enr.inputs$gene2Symbol, pvalueCutoff = enrp.max, minGSSize = enr.min.genes))
                if (!is(my.ora.res, class2 = 'try-error')) ora.output(enrichResult = my.ora.res, out.dir = de.dir, comp.name = cur.name, geneList = enr.inputs$gsea.genevec)
              }
            }
          }
        }
        
        ## KEGG/MKEGG
        ### NOTE1 : It's the same way to call the 'gsea.run' / 'ora.run' as it is for 'DO', 'NCG' or 'DGN', but here it's compatible with many more species than homo sapiens.
        ### NOTE2 : for this case, additional KEGG pathway plots will be generated.
        ### NOTE3 : for this case, an internet connexion is required to query the KEGG website.
        if (any(kegg.do)) {
          ### GSEA
          if (kegg.do[1]) {
            for (x in c('clusterProfiler::gseKEGG', 'clusterProfiler::gseMKEGG')) {
              my.gsea.res <- try(gsea.run(geneList = enr.inputs$gsea.genevec, species = species, func.name = x, t2g = NULL, t2g.name = NULL, gene2Symbol = enr.inputs$gene2Symbol, seed = my.seed, pvalueCutoff = enrp.max, minGSSize = enr.min.genes))
              if (!is(my.gsea.res, class2 = 'try-error')) gsea.output(gseaResult = my.gsea.res, out.dir = de.dir, comp.name = cur.name)
            }
            ### ORA
            if(kegg.do[2]) {
              for (x in c('clusterProfiler::enrichKEGG', 'clusterProfiler::enrichMKEGG')) {
                my.ora.res <- try(ora.run(gene = enr.inputs$ora.genevec, species = species, func.name = x, t2g = NULL, t2g.name = NULL, gene2Symbol = enr.inputs$gene2Symbol, pvalueCutoff = enrp.max, minGSSize = enr.min.genes))
                if (!is(my.ora.res, class2 = 'try-error')) ora.output(enrichResult = my.ora.res, out.dir = de.dir, comp.name = cur.name, geneList = enr.inputs$gsea.genevec)
              }
            }
          }
        }
        
        ## WP (wikipathways)
        if(any(wp.do)) { 
          if(wp.do[1]) {
            ### GSEA
            func.name <- 'clusterProfiler::gseWP'
            my.gsea.res <- try(gsea.run(geneList = enr.inputs$gsea.genevec, organism = species, func.name = func.name, t2g = NULL, t2g.name = NULL, gene2Symbol = enr.inputs$gene2Symbol, seed = my.seed, pvalueCutoff = enrp.max, minGSSize = enr.min.genes))
            if (!is(my.gsea.res, class2 = 'try-error')) gsea.output(gseaResult = my.gsea.res, out.dir = de.dir, comp.name = cur.name)
          }
          ### ORA
          if(wp.do[2]) {
            func.name <- 'clusterProfiler::enrichWP'
            my.ora.res <- ora.run(gene = enr.inputs$ora.genevec, organism = species, func.name = func.name, t2g = NULL, t2g.name = NULL, gene2Symbol = enr.inputs$gene2Symbol, pvalueCutoff = enrp.max, minGSSize = enr.min.genes)
            if (!is(my.ora.res, class2 = 'try-error')) ora.output(enrichResult = my.ora.res, out.dir = de.dir, comp.name = cur.name, geneList = enr.inputs$gsea.genevec)
          }
        }
        
        ## REACTOME
        if (any(reactome.do)) {
          org.name <- paste0(msigdbr2org(species = species), '.db')
          library(org.name, character.only = TRUE)
          reactome.org <- tolower(convert_species_name(OrgDb = get(org.name)))
          if(reactome.do[1]) {
            ### GSEA
            func.name <- 'ReactomePA::gsePathway'
            my.gsea.res <- gsea.run(geneList = enr.inputs$gsea.genevec, organism = reactome.org, func.name = func.name, t2g = NULL, t2g.name = NULL, gene2Symbol = enr.inputs$gene2Symbol, seed = my.seed, pvalueCutoff = enrp.max, minGSSize = enr.min.genes)
            my.gsea.res@setType <- paste0(func.name, '_Reactome')
            gsea.output(gseaResult = my.gsea.res, out.dir = de.dir, comp.name = cur.name)
          }
          if(reactome.do[2]) {
            ### ORA
            func.name <- 'ReactomePA::enrichPathway'
            my.ora.res <- ora.run(gene = enr.inputs$ora.genevec, organism = reactome.org, func.name = func.name, t2g = NULL, t2g.name = NULL, gene2Symbol = enr.inputs$gene2Symbol, pvalueCutoff = enrp.max, minGSSize = enr.min.genes)
            my.ora.res@ontology <- paste0(func.name, '_Reactome')
            ora.output(enrichResult = my.ora.res, out.dir = de.dir, comp.name = cur.name, geneList = enr.inputs$gsea.genevec)
          }
        }
        
        ## CELLMARKER
        ### Assess cell types from an online table
        ### NOTE : It's the same way to call the 'gsea.run' / 'ora.run' functions as for MSIGDB, but with a single bank (so, no loop).
        # if (any(cm.do)) {
        #   ### GSEA
        #   if (cm.do[1]) {
        #     my.gsea.res <- try(gsea.run(geneList = enr.inputs$gsea.genevec, species = species, func.name = 'clusterProfiler::GSEA', t2g = cell_markers, t2g.name = 'CellMarker', gene2Symbol = enr.inputs$gene2Symbol, seed = my.seed, pvalueCutoff = enrp.max, minGSSize = enr.min.genes))
        #     if (!is(my.gsea.res, class2 = 'try-error')) gsea.output(gseaResult = my.gsea.res, out.dir = de.dir, comp.name = mycomb)
        #   }
        #   #### ORA
        #   if (cm.do[2]) {
        #     my.ora.res <- try(ora.run(gene = enr.inputs$ora.genevec, species = species, func.name = 'clusterProfiler::enricher', t2g = cell_markers, t2g.name = 'CellMarkers', gene2Symbol = enr.inputs$gene2Symbol, pvalueCutoff = enrp.max, minGSSize = enr.min.genes))
        #     if (!is(my.ora.res, class2 = 'try-error')) ora.output(enrichResult = my.ora.res, out.dir = de.dir, comp.name = mycomb, geneList = enr.inputs$gsea.genevec)
        #   }
        # }
        
        ## MESH (WARNING : MEMORY OGRE AND SLOW !! Big DBs, 3 sources, 16 categories ! 64 GB of RAM required for most bases !
        ### Requires additional parameters :
        ### . 'MeSHDb' : character ; name of a MeSH [NO : AUTO FROM SPECIES NAME]
        ### . 'database' : character ; MeSH source type (can be 'gendoo' = text-mining, 'gene2pubmed' = manual curation by NCBI team, 'RBBH' = sequence homology with BLASTP search @ E-value < 1E-50)
        ### . 'category' : character ; name of a MeSH category sub-db (namely 'A', 'B', 'C', 'D', 'G').
        ### NOTE : see https://yulab-smu.top/biomedical-knowledge-mining-book/meshes-semantic-similarity.html
        if (any(mesh.do)) {
          ### List of requested MeSH DBs
          mesh.dbs <- c('gendoo', 'gene2pubmed', 'RBBH') ## 'RBBH' is not available for Homo sapiens.
          ### List of requested MeSH categories
          mesh.categories <- toupper(letters[-c(15:21,23:25)]) ## More categories are available, but some do not seem to work with Homo sapiens for some of the DBs.
          ### Building the MeSH package name corresponding to the current species
          mesh.sp <- paste0(c('MeSH.', substr(unlist(strsplit(species, ' ')), c(1, 1), c(1,2)), '.eg.db'), collapse = '')
          ### Checking which MeSH DBs are available for the current species.
          mesh.dbs <- MeSHDbi::listDatabases(eval(parse(text = paste0(mesh.sp, '::', mesh.sp))))[,1]
          
          ### ORA
          #### WARNING !! the 'gene2pubmed' requires a lot of RAM (~12 GB) !!
          if (mesh.do[2]) {
            mesh.func.name <- 'meshes::enrichMeSH'
            for (y in mesh.dbs) {
              for (x in mesh.categories) {
                message(paste0(y, ' ', x))
                if (y %in% mesh.dbs) {
                  my.ora.res <- try(ora.run(gene = enr.inputs$ora.genevec, species = species, func.name = mesh.func.name, t2g = NULL, t2g.name = NULL, gene2Symbol = enr.inputs$gene2Symbol, pvalueCutoff = enrp.max, minGSSize = enr.min.genes, database = y, category = x))
                  if(!is(my.ora.res, class2 = 'try-error')) {
                    ## Little hack specific to MeSH results (as I was not able to get the value of extra parameters 'database' and 'category' from within the 'gsea.run()' function)
                    my.ora.res@ontology <- paste(c(mesh.func.name, y, x), collapse = '_')
                    ora.output(enrichResult = my.ora.res, out.dir = de.dir, comp.name = cur.name, geneList = enr.inputs$gsea.genevec)
                  }
                } else message(paste0("Unsupported MeSH database '", y, "'. Expecting one of : '", paste(mesh.dbs, collapse = "', '"), "'."))
              }
            }
          }
          
          ### GSEA
          #### WARNING !! Needs too much memory for a laptop (probably over 64 GB of RAM, easily...). SO, not recommended out of flamingo.
          if(mesh.do[1]) {
            mesh.func.name <- 'meshes::gseMeSH'
            for (y in mesh.dbs) {
              for (x in mesh.categories) {
                message(paste0(y, ' ', x))
                if (y %in% mesh.dbs) {
                  my.gsea.res <- try(gsea.run(geneList = enr.inputs$gsea.genevec, species = species, func.name = mesh.func.name, t2g = NULL, t2g.name = NULL, gene2Symbol = enr.inputs$gene2Symbol, seed = my.seed, pvalueCutoff = enrp.max, minGSSize = enr.min.genes, database = y, category = x), silent = TRUE)
                  if (!is(my.gsea.res, class2 = 'try-error')) {
                    ## Little hack specific to MeSH results (as I was not able to get the value of extra parameters 'database' and 'category' from within the 'gsea.run()' function)
                    my.gsea.res@setType <- paste(c(mesh.func.name, y, x), collapse = '_')
                    gsea.output(gseaResult = my.gsea.res, out.dir = de.dir, comp.name = cur.name)
                  }
                } else message(paste0("Unsupported MeSH database '", y, "'. Expecting one of : '", paste(mesh.dbs, collapse = "', '"), "'."))
              }
            }
          }
          
          ## CUSTOM
          if (any(custom.do) & !is.null(custom_gmt_list)) {
            for (cdb in names(custom_gmt_list)) {
              if(reactome.do[1]) {
                ### GSEA
                func.name <- 'clusterProfiler::GSEA'
                my.gsea.res <- gsea.run(geneList = enr.inputs$gsea.genevec, organism = species, func.name = func.name, t2g = custom_gmt_list[[cdb]], t2g.name = cdb, gene2Symbol = enr.inputs$gene2Symbol, seed = my.seed, pvalueCutoff = enrp.max, minGSSize = enr.min.genes)
                gsea.output(gseaResult = my.gsea.res, out.dir = de.dir, comp.name = cur.name)
              }
              if(reactome.do[2]) {
                ### ORA
                func.name <- 'clusterProfiler::enricher'
                my.ora.res <- ora.run(gene = enr.inputs$ora.genevec, organism = species, func.name = func.name, t2g = custom_gmt_list[[cdb]], t2g.name = cdb, gene2Symbol = enr.inputs$gene2Symbol, pvalueCutoff = enrp.max, minGSSize = enr.min.genes)
                ora.output(enrichResult = my.ora.res, out.dir = de.dir, comp.name = cur.name, geneList = enr.inputs$gsea.genevec)
              }
            }
          }
        }
      }
  }
}

## Wrapper for boxplots with stripchart, except for outliers [LIST VERSION]
boxplot2l <- function(x = list(), col = 'lightgray', fill = NULL, main = 'boxplot2', xlab = '', ylab = 'Y', vertical = TRUE, ylim = NULL, cex = 1, line.type = 'medsd') {
  x.meds <- sapply(x, function(i) { median(i, na.rm = TRUE) })
  glob.med <- median(unlist(x), na.rm = TRUE)
  glob.sd <- sd(unlist(x), na.rm = TRUE)
  x.Q1 <- sapply(x, function(i) { quantile(x = i, probs = .25, na.rm = TRUE) })
  x.Q3 <- sapply(x, function(i) { quantile(x = i, probs = .75, na.rm = TRUE) })
  x.IQR <- x.Q3 - x.Q1
  x.len <- sapply(x, length)
  x.noO <- lapply(seq_along(x), function(i) { x[[i]][x[[i]] >= (x.Q1[i] - (1.5 * x.IQR[i])) &  (x[[i]] <= x.Q3[i] + (1.5 * x.IQR[i]))] })
  names(x.noO) <- names(x)
  ## Setting ylim
  if (is.null(ylim)) ylim = range(unlist(x), na.rm = TRUE)
  marb <- round(max(nchar(names(x)))*.75)
  par(mar=c(marb, 4, 2, 2) + 0.1)
  boxplot(x = x, col = fill, border = col, main = paste0(main, ' (', sum(x.len), ')'), ylab = ylab, names = NA, lwd = 2, ylim = ylim, pch = 20, cex = cex)
  stripchart(x = x.noO, method = 'jitter', vertical = vertical, add = TRUE, col = col, pch = 20, cex = cex)
  if(!is.null(line.type)) { if(line.type == 'medsd') abline(h = glob.med + c(0, glob.sd, -glob.sd), col = 2, lty = c(2,3,3), lwd = 2) else if(line.type == 'quantiles') abline(h = c(x.Q1, x.Q3), col = 2, lty = c(3,3), lwd = 2)
  }
  axis(1, at=1:length(x), labels=paste0(names(x), ' (', x.len, ')'), las = 2)
}


## Function to aggregate results from multiple differential analyses as a heatmap of the "top" features from each. Top selection can be TopN, Adjp threshold, quantile. The output is a clustered heatmap (mimicking the heatmap from Seurat for FindAllMarkers results)
## exp.mat                matrix(integer)     Sample x feature (gene) normalized expression matrix. Feature names as rownames.
## dea_res_list           list(data.frames)   List that contains the output table of multiple differential analyses (see diffexp_design)
## annot.df               data.frame          Sample annotations. Should contain a column with the same entries as colnames(exp.mat) and 
## selec_list             list()              List that contains the type of selection to perform on each DEA result
MultHeatMap <- function(exp_mat = NULL, dea_res_list = NULL, annot_df = NULL, selec_list = NULL, logFC_pos = FALSE) {
  
}


## Generates a vetor of distinctive colors
distinct_color_maker <- function(n_colors = 10, my_seed = 1337, ...) {
  set.seed(my_seed)
  cvec <- randomcoloR::distinctColorPalette(k = n_colors, ...)
  return(cvec)
}

## Converts raw intensities/counts to log (custom base) with an added epsilon (by exemple : counts to log10(counts+1))
raw2log <- function(x = NULL, log_base = 10, epsilon = 1) {
  if (!is.matrix(x)) stop ('x must be a matrix !')
  return(log( x + epsilon ) / log(log_base))
}

## Draws boxplots from a matrix with custom ordering/coloring from a factor annotation in a df. WARNING : x and annot_df must be synched !
categ.boxplot <- function(x = NULL, annot_df = annot_df, col_item = 'Batch', title = "Boxplot", y_lab = "Y label", my_seed = 1337) {
  if (!is.matrix(x)) stop('x must be a matrix !')
  if (!is.data.frame(annot_df)) stop ('annot_df must be a data.frame !')
  if (! col_item %in% colnames(annot_df)) stop ('There is no [', col_item, '] column in annot_df !')
  annot_vec <- as.factor(annot_df[[col_item]])
  medz <- matrixStats::colMedians(x, na.rm = TRUE)
  ord_annot <- order(annot_vec, medz, decreasing = c(FALSE, TRUE))
  col_pal <- distinct_color_maker(n_colors = max(as.numeric(annot_vec), na.rm = TRUE))
  nblocks = ceiling(sqrt(length(col_pal)))
  ori_par <- par(no.readonly = TRUE)
  par(xaxs = 'i')
  boxplot(x[, ord_annot], col = col_pal[as.numeric(annot_vec[ord_annot])], main = title, xaxt = "n", xlab = "Samples", ylab = y_lab)
  legend('topleft', legend = unique(annot_vec[ord_annot]), text.col = col_pal, cex = 1, title.col = 1, title.cex = 1, y.intersp = .75, ncol = nblocks, x.intersp = 0, text.font = 2)
  par(ori_par)
}

## Get medoids of a vector
get_medoid <- function(x = NULL, split = NULL) {
  split[is.na(split)] <- "NA"
  xsplit <- split(x, as.factor(split))
  xmed <- vapply(X = xsplit, function(y) { median(y, na.rm = TRUE)}, .1)
  return(xmed)
}

## Run immunedeconv on a matrix
immunedeconv_run <- function(exp_mat = NULL, to_tpm = TRUE, methods = c('quantiseq', 'epic', 'estimate', 'mcp_counter', 'abis', 'cibersort'), is_array = FALSE, is_tumor = TRUE, cibersort_binary_path = NULL, cibersort_lm22_path = NULL, cibersort_absolute = TRUE, cibersortx_resfile = NULL, cibersortx_absolute = TRUE) {
  
  if (to_tpm) {
    ## Normalize to TPM
    message('Transforming data to TPM')
    for (s in colnames(exp_mat)) exp_mat[,s] <- immunedeconv::scale_to_million(sample = exp_mat[,s])
  }
  
  ## EPIC handling
  if ('epic' %in% methods) library(EPIC)
  
  ## Running with (multiple) method(s)
  id_res_all <- lapply(id_methods, function(idm) {
    message('. ', idm)
    if (tolower(idm) == 'cibersort') {
      immunedeconv::set_cibersort_binary(cibersort_binary_path)
      immunedeconv::set_cibersort_mat(cibersort_lm22_path)
      suppressMessages(id_try <- try(id_resC <- immunedeconv::deconvolute_cibersort(gene_expression = exp_mat, arrays = is_array, absolute = cibersort_absolute)))
      id_res <- if (is(id_try, class2 = 'try-error')) NULL else tibble::as_tibble(data.frame('cell_type' = rownames(id_resC), id_resC))
      rm(id_resC)
    } else {
      ## xCell handling
      if (idm == 'xcell') xCell.data <<- immunedeconv::xCell.data
      suppressWarnings(suppressMessages(id_try <- try(id_res <- immunedeconv::deconvolute(gene_expression = exp_mat, method = idm, tumor = is_tumor, arrays = is_array))))
      ## xCell handling
      if (idm == 'xcell' & exists('xCell.data')) rm(xCell.data, envir = globalenv())
      ## ERROR handling
      if (is(id_try, class2 = 'try-error')) id_res <- NULL
    }
    return(id_res)
  })
  names(id_res_all) <- id_methods
  if (cibersort_absolute) names(id_res_all)[names(id_res_all) == 'cibersort'] <- 'cibersort_absolute'
  
  ## Unloading EPIC if needed
  if ('epic' %in% methods & 'EPIC' %in% .packages()) detach("package:EPIC", unload = FALSE) ## unload is set to false as EPIC is actually loaded by immunedeconv
  
  ## Clean CiberSort output (extract global score)
  for (cidword in c('cibersort', 'cibersort_absolute')) {
    if (cidword %in% names(id_res_all)) {
      score_range <- nrow(id_res_all[[cidword]])
      id_res_all[[paste0(cidword, '_score')]] <- id_res_all[[cidword]][score_range,, drop = FALSE]
      id_res_all[[cidword]] <- id_res_all[[cidword]][-c(nrow(id_res_all[[cidword]])),, drop = FALSE]
    }
  }
  
  ## Clean MCPcounter output (extract global scores)
  if ('mcp_counter' %in% names(id_res_all)) {
    score_range <- 3
    id_res_all$mcp_counter_score <- id_res_all$mcp_counter[score_range,, drop = FALSE]
    id_res_all$mcp_counter <- id_res_all$mcp_counter[-c(score_range),, drop = FALSE]
  }
  
  ## Clean XCell output (extract global scores)
  if ('xcell' %in% names(id_res_all)) {
    score_range <- (nrow(id_res_all$xcell)-2):nrow(id_res_all$xcell)
    id_res_all$xcell_score <- id_res_all$xcell[score_range,, drop = FALSE]
    id_res_all$xcell <- id_res_all$xcell[-c(score_range),, drop = FALSE]
  }
  
  ## Add CiberSortX results ?
  if (!is.null(cibersortx_resfile)) {
    cbx_res <- data.table::fread(file = cibersortx_resfile, sep = '\t', header = TRUE, data.table = FALSE)
    cbx_mat <- t(as.matrix(cbx_res[,-1]))
    cbx_tib <- tibble::as_tibble(data.frame('cell_type' = colnames(cbx_res)[-1], cbx_mat))
    colnames(cbx_tib) <- c('cell_type', cbx_res[,1])
    absword <- if(cibersortx_absolute) 'absolute' else NULL
    ## Split results ...
    score_range <- (nrow(cbx_tib)-3):nrow(cbx_tib)
    ### ... quantifications
    id_res_all[[paste(c('cibersortx', absword), collapse = '_')]] <- cbx_tib[-c(score_range),]
    ### ... scores/metrics
    id_res_all[[paste(c('cibersortx', absword, 'score'), collapse = '_')]] <- cbx_tib[score_range,]
    rm(cbx_res, cbx_tib, cbx_mat)
  }
  return(id_res_all)
}

## Barplot for immunedeconv results
immunedeconv_barplot <- function(id_res = NULL, title = 'ImmuneDeconv') {
  id_plotdata <- tidyr::gather(data = id_res, key = sample, value = fraction, -cell_type)
  id_plot <- ggplot2::ggplot(data = id_plotdata, mapping = ggplot2::aes(x = sample, y = fraction, fill = cell_type)) + ggplot2::geom_bar(stat = "identity") + ggplot2::coord_flip() + ggplot2::scale_fill_manual(values = colorRampPalette(RColorBrewer::brewer.pal(name = "Set1", n = 8))(nrow(id_res))) + ggplot2::scale_x_discrete(limits = rev(levels(id_res))) + ggplot2::ggtitle(title)
  print(id_plot)
}

## Perform GSVA on a symbols x samples normalized expression matrix
gsva_run <- function(exp_mat = NULL, gmt_files = NULL, enr_min_genes = 10, species = 'homo sapiens', out_dir = getwd()) {
  ## Checks
  if (is.null(exp_mat)) stop('An expression matrix is required !')
  if (is.null(gmt_files)) stop('No GMT provided !')
  if (!is.matrix(exp_mat)) stop('Provided exp_mat is not a matrix !')
  if (!all(file.exists(gmt_files))) stop('At least one of the provided GMT(s) was not found !')
  if (!dir.exists(paths = out_dir)) stop('Provided out_dir does not exist !')
  
  ## Run
  
  ## Generate GMT names (for output)
  gmt_names <- sub(pattern = '\\.gmt.*$', replacement = '', x = basename(gmt_files))
  
  ## Convert feature names to ENTREZ
  ### Convert species name to org-compatible identifier
  if (tolower(species) == 'homo sapiens') {
    Org <- 'org.Hs'
  } else if (tolower(species) == 'mus musculus') {
    Org <- 'org.Mm'
  } else {
    message('Only "homo sapiens" and "Mus musculus" are supported !')
    Org <- NULL
  }
  ### Convert expression features to ENTREZ
  g_conv <- suppressWarnings(suppressMessages(clusterProfiler::bitr(geneID = rownames(exp_mat), fromType = 'SYMBOL', toType = 'ENTREZID', OrgDb = paste0(Org, '.eg.db'))))
  g_conv <- g_conv[!(duplicated(g_conv$SYMBOL) | duplicated(g_conv$ENTREZID)),]
  s2e <- setNames(object = g_conv$ENTREZID, nm = g_conv$SYMBOL)
  rm(g_conv)
  geo_gsva <- exp_mat[rownames(geo_norm) %in% names(s2e),]
  rownames(geo_gsva) <- s2e[rownames(geo_gsva)]
  rm(s2e, exp_mat)
  
  ## Looping on GMTs
  gsva_all <- lapply(seq_along(gmt_files), function(g) {
    
    gmt_file <- gmt_files[g]
    gmt_name <- gmt_names[g]
    message('. ', gmt_name)
    
    ## Read terms from GMT
    gmt_db <- suppressWarnings(suppressMessages(GSEABase::getGmt(con = gmt_file, geneIdType = GSEABase::EntrezIdentifier(), collectionType = GSEABase::NullCollection())))
    
    ## Create gParam from expression matrix and terms
    g_param <- suppressWarnings(suppressMessages(GSVA::gsvaParam(exprData = geo_gsva, geneSets = gmt_db, kcdf = 'Gaussian', minSize = enr_min_genes)))
    ## Run GSVA
    gsva_res <- suppressWarnings(suppressMessages(GSVA::gsva(expr = g_param, verbose = FALSE)))
    
    ### OL detection : grDevices::boxplot.stats
    bx_res <- lapply(seq_len(ncol(gsva_res)), function(k) {
      es_data <- gsva_res[,k, drop = TRUE]
      es_res <- boxplot.stats(x = es_data)
      es_data[!names(es_data) %in% names(es_res$out)] <- NA
      return(es_data)
    })
    bx_mat <- Reduce(f = cbind, x = bx_res)
    dimnames(bx_mat) <- dimnames(gsva_res)
    bx_df <- data.frame(data.frame(Term = gsub(pattern = '\\%', replacement = '_', x = rownames(bx_mat)), bx_mat, OCC = ncol(bx_mat) - matrixStats::rowCounts(x = bx_mat, value = NA, na.rm = FALSE)))
    bx_df$FREQ <- bx_df$OCC / ncol(bx_mat)
    rm(bx_mat)
    
    ## OL detection : Rosner test
    ro_res <- lapply(seq_len(ncol(gsva_res)), function(k) {
      es_data <- gsva_res[,k, drop = TRUE]
      es_res <- EnvStats::rosnerTest(x = es_data, k = ceiling(length(es_data)/2), warn = FALSE)
      es_data[es_res$all.stats$Outlier == FALSE] <- NA
      return(es_data)
    })
    ro_mat <- Reduce(f = cbind, x = ro_res)
    dimnames(ro_mat) <- dimnames(gsva_res)
    ro_df <- data.frame(data.frame(Term = gsub(pattern = '\\%', replacement = '_', rownames(ro_mat)), ro_mat, OCC = ncol(ro_mat) - matrixStats::rowCounts(x = ro_mat, value = NA, na.rm = FALSE)))
    ro_df$FREQ <- ro_df$OCC / ncol(ro_mat)
    rm(ro_mat)
    
    ## Aggregate tables to output
    gsva_outlist <- list(GSVA = data.frame(Term = gsub(pattern = '\\%', replacement = '_', rownames(gsva_res)), gsva_res, check.names = FALSE), OL_BOXP_TEST = bx_df, OL_ROSNER_TEST = ro_df)
    rm(bx_df, ro_df)
    
    ## Write with openxlsx
    ### Create workbook
    wb <- openxlsx::createWorkbook(title = paste0(gmt_name, ' GSVA results'))
    ### Define styles
    Hstyle <- openxlsx::createStyle(halign = 'center', valign = 'bottom', textRotation = 90, textDecoration = 'bold')
    FLOATstyle <- openxlsx::createStyle(numFmt = '0.000')
    INTstyle <- openxlsx::createStyle(numFmt = '0')
    PCstyle <- openxlsx::createStyle(numFmt = '0.00%')
    ### Add sheets
    for (l in names(gsva_outlist)) {
      cur.hh <- min(max(sapply(colnames(gsva_outlist[[l]]), nchar)), 30) * 9
      cur.fc <- min(max(sapply(gsva_outlist[[l]][,1], nchar)), 30) * 3
      openxlsx::addWorksheet(wb = wb, sheetName = l)
      openxlsx::setRowHeights(wb = wb, sheet = l, rows = 1, heights = cur.hh)
      openxlsx::addStyle(wb = wb, sheet = l, style = Hstyle, rows = 1, cols = 1:ncol(gsva_outlist[[l]]))
      numstyle_colz <- if(l == 'GSVA') 2:ncol(gsva_outlist[[l]]) else 2:(ncol(gsva_outlist[[l]])-2)
      ### Apply 3-digits float formatting for score columns
      openxlsx::addStyle(wb = wb, sheet = l, style = FLOATstyle, rows = 2:(nrow(gsva_outlist[[l]])+1), cols = numstyle_colz, gridExpand = TRUE, stack = TRUE)
      if(l != 'GSVA') {
        ### Apply integer formatting for OCC column
        openxlsx::addStyle(wb = wb, sheet = l, style = INTstyle, rows = 2:(nrow(gsva_outlist[[l]])+1), cols = ncol(gsva_outlist[[l]]) - 1, gridExpand = TRUE, stack = TRUE)
        ### Apply percent formatting for FREQ column
        openxlsx::addStyle(wb = wb, sheet = l, style = PCstyle, rows = 2:(nrow(gsva_outlist[[l]])+1), cols = ncol(gsva_outlist[[l]]), gridExpand = TRUE, stack = TRUE)
      }
      openxlsx::setColWidths(wb = wb, sheet = l, cols = 2:ncol(gsva_outlist[[l]]), widths = 6)
      openxlsx::setColWidths(wb = wb, sheet = l, cols = 1, widths = cur.fc)
      openxlsx::freezePane(wb = wb, sheet = l, firstRow = TRUE, firstCol = TRUE)
      openxlsx::writeData(wb = wb, sheet = l, x = gsva_outlist[[l]], keepNA = TRUE, na.string = 'NA')
    }
    ## Write
    openxlsx::saveWorkbook(wb = wb, file = paste0(out_dir, '/', gmt_name, '_GSVA_results.xlsx'), overwrite = TRUE)
    rm(wb)
    
    ## Return
    return(gsva_res)
  })
  names(gsva_all) <- gmt_names
  return(gsva_all)
}


## Perform Kruskal-Wallis differential test on GSVA results according to clinical annotation
gsva_diff_run <- function(gsva_res = NULL, annot_df = NULL, diff_factor = NULL, max.p = .05, out_dir = getwd()) {
  
  ## Checks
  if (is.null(gsva_res)) stop('An output of gsva_run() is required !')
  if (!is.list(gsva_res)) stop('gsva_res should be a list, the output of gsea_run() !')
  if (is.null(diff_factor)) stop('A list of annotation to perform the differential tests is required !')
  # if (!is.list(diff_factor)) stop('diff_factor should be a list !')
  if (is.null(annot_df)) stop('No annotation table provided !')
  if (!is.numeric(max.p)) stop('max_p should be a numeric in ]0:1] !')
  if (max.p <= 0) stop('max_p should be a numeric in ]0:1] !')
  if (max.p > 1) stop('max_p should be a numeric in ]0:1] !')
  if (!dir.exists(paths = out_dir)) stop('Provided out_dir does not exist !')
  
  ## Run
  ## Looping on factors to compare
  grd_all <- lapply(prop_factors, function(ppf) {
    message('. ', ppf)
    ## Looping on gsva results
    grdiff_all <- lapply(names(gsva_all), function(ga) {
      message('  . ', ga)
      ## Looping on terms
      kw_l <- sapply(seq_len(nrow(gsva_all[[ga]])), function(x) {
        # message(x)
        data_df <- data.frame(gsva = unname(unlist(gsva_all[[ga]][x,])), class = annot_df[[ppf]])
        kw_t <- kruskal.test(gsva ~ class, data = data_df)
        kw_df <- data.frame(Statistic = kw_t$statistic, raw.p = kw_t$p.value, adj.p = 0.0)
        ## Add classes median
        ksumry <- aggregate(gsva ~ class, data = data_df, summary)
        ksd <- aggregate(gsva ~ class, data = data_df, sd)
        for (kx in seq_len(nrow(ksumry$gsva))) {
          kw_df[[paste0('Median_', ksumry$class[kx])]] <- ksumry$gsva[kx, 'Median']
          kw_df[[paste0('Sd_', ksd$class[kx])]] <- ksd$gsva[kx]
        }
        return(kw_df)
      }, simplify = FALSE)
      kw_res <- data.frame(Term = gsub(pattern = '\\%', replacement = '_', x = rownames(gsva_all[[ga]])), Reduce(f = rbind, x = kw_l))
      rm(kw_l)
      return(kw_res)
    })
    names(grdiff_all) <- names(gsva_all)
    
    ## Add AdjP
    for (l in names(grdiff_all)) grdiff_all[[l]]$adj.p <- p.adjust(p = grdiff_all[[l]]$raw.p, method = "BH")
    
    ## Output results
    Hstyle <- openxlsx::createStyle(halign = 'center', valign = 'center', textDecoration = 'bold')
    FLOATstyle <- openxlsx::createStyle(numFmt = '0.000')
    SCstyle <- openxlsx::createStyle(numFmt = '0.00E00')
    BLUEstyle <- openxlsx::createStyle(bgFill = 'lightblue')
    wb <- openxlsx::createWorkbook(title = paste0(ppf, ' GSVA DiffTest'))
    for (l in names(grdiff_all)) {
      sname <- strtrim(x = l, width = 31)
      cur.fc <- min(max(sapply(grdiff_all[[l]][,1], nchar)), 30) * 3
      openxlsx::addWorksheet(wb = wb, sheetName = sname)
      openxlsx::addStyle(wb = wb, sheet = sname, style = Hstyle, rows = 1, cols = 1:ncol(grdiff_all[[l]]))
      openxlsx::addStyle(wb = wb, sheet = sname, style = FLOATstyle, rows = 2:(nrow(grdiff_all[[l]])+1), cols = c(2,5:ncol(grdiff_all[[l]])+1), gridExpand = TRUE, stack = TRUE)
      openxlsx::addStyle(wb = wb, sheet = sname, style = SCstyle, rows = 2:(nrow(grdiff_all[[l]])+1), cols = 3:4, gridExpand = TRUE, stack = TRUE)
      openxlsx::conditionalFormatting(wb = wb, sheet = sname, rows = 2:(nrow(grdiff_all[[l]])+1), cols = 3:4, rule = paste0('<', max.p), style = BLUEstyle)
      openxlsx::setColWidths(wb = wb, sheet = sname, cols = 2:4, widths = 10)
      openxlsx::setColWidths(wb = wb, sheet = sname, cols = 1, widths = cur.fc)
      openxlsx::freezePane(wb = wb, sheet = sname, firstRow = TRUE, firstCol = TRUE)
      ## Add sheet
      openxlsx::writeData(wb = wb, sheet = sname, x = grdiff_all[[l]], keepNA = TRUE, na.string = 'NA')
    }
    ## Save XLSX
    openxlsx::saveWorkbook(wb = wb, file = paste0(out_dir, '/', ppf, '_GSVA_DiffTest.KW_results.xlsx'), overwrite = TRUE)
    rm(wb)
    return(grdiff_all)
  })
  names(grd_all) <- unlist(prop_factors)
  return(grd_all)
}
