#!/usr/bin/perl
use strict;

my $version = '1.1b 20140911';

## NOTES DE VERSION;
##
## 1.1c 20160729
##	. Replaced --proj and --db by --ldb (to get rid of pelican repositories).
##
## 1.1b	20140911
#	. Changed option names to be more POSIX-compliant.
##
## 1.1	20120201
##	. argument de la p.value '-p' en 'p$' pour ne pas confondre avec 'proj'
##	. Ajout des arguments 'proj' et 'db' pour lancer grd
##
## 1.0	20120201
##	. New script based on clicoselM, with the same behaviour, but launching grd instead of the deprecated genrdescM.


# my $design = '';
my $repfilez = '';

# defaults;
my $thres = 0.05;
my $mode = 'cc_categ';
my $minfreq = 0.1;
my $minprob = 2;
my $grd = 'Y';
my $sp = 'hs';
my $gb = 19;
# my $proj = '/mnt/proj/';
# my $db = '/mnt/db/';
my $ldb = '/mnt/data_cigogne/bioinfo/';
my $nt = 1;


foreach (@ARGV) {
	chomp;
}

if (@ARGV == 0) {
	print '
cc2grd v'.$version.'
 for Clinical Comparisons selector to grd (from clicoM.R script results)

DESCRIPTION: This script allows to select most relevant
 differential regions between two compared populations,
 from an output of the clicoM.R script, and launches grd
 on the selection.

USAGE:
cc2grd [file(s)] -p [value] --mode [cc_categ|cc_conti] --mf [value] --mp [value] --grd [Y|N] --sp [hs|mm|rn] --gb [17|18|19|38|9|10|4|5|6] --ldb [/mnt/data_cigogne/bioinfo] -n [1]

ARGUMENTS:
	[file(s)]	Data files generated by clicoM.R
 	-p	Minimum threshold fo the p-value, to consider a
		relevant differential region between the two compaired
		sub-populations. ['.$thres.']
	--mode	Mode to use with grd for categorical or continuous data ['.$mode.'].
	--mf	Minimum frequency for an aberration to consider its
		status as abnormal. ['.$minfreq.']
	--mp	Minimum length (in probes). Default ['.$minprob.']
	--grd	Specifiy if grd should be automaticaly run to
		annotate the selected regions. ['.$grd.']
	--sp	Species. ['.$sp.']
	--gb	Genome build. ['.$gb.']
	--ldb	Path to a local mirror of public databases. ['.$ldb.']
	-n	Number of threads for multithreaded run. ['.$nt.']

NOTA 1:	--sp and --gb only needed if --grd is set to Y

NOTA 2:	Special characters like \* and \? can
	be used, but you must add the \'\\\' too.
	Ex: /ws/ugf/bioinfo/test/clicoselected/\*.txt

';
exit;
}


$repfilez = $ARGV[0];

foreach my $i (1..$#ARGV-1) {
	if ($ARGV[$i] =~ /^-p$/) { $thres = $ARGV[$i+1]; }
	elsif ($ARGV[$i] =~ /^--mode$/) { $mode = $ARGV[$i+1]; }
	elsif ($ARGV[$i] =~ /^--mf$/) { $minfreq = $ARGV[$i+1]; }
	elsif ($ARGV[$i] =~ /^--mp$/) { $minprob = $ARGV[$i+1]; }
	elsif ($ARGV[$i] =~ /^--grd$/) { $grd = $ARGV[$i+1]; }
	elsif ($ARGV[$i] =~ /^--sp$/) { $sp = $ARGV[$i+1]; }
	elsif ($ARGV[$i] =~ /^--gb$/) { $gb = $ARGV[$i+1]; }
	elsif ($ARGV[$i] =~ /^--ldb$/) { $ldb = $ARGV[$i+1]; }
	elsif ($ARGV[$i] =~ /^-n$/)	{ $nt = $ARGV[$i+1]; }
}

my %spconv = ('hs' => 'hg', 'mm' => 'mm');
my $gv = $spconv{lc($sp)}.$gb;

print '
Clinical comparisons input file(s) :
   '.$repfilez.'
Working on '.$gv.'
Threshold for maximum P-value : '.$thres.'
GRD mode : '.$mode.'
Minimal FREQUENCY to consider a representative aberration : '.$minfreq.'
';



my %hash=();

my @infiles = `ls $repfilez`;
print @infiles." file(s) found.\n";

foreach my $file (@infiles) {
	chomp $file;
	
	print 'Dealing with '.$file."\n";
	my $outfile = (split /\//, $file)[-1];
	open INDAT, $file or die $!;
	my @BO=();
	my $regz=0;
	
	foreach (<INDAT>) {
		$_ =~ s/\n//;
		$_ =~ s/\r//;
		
		my @temp = split /\t/, $_;
		my @outline=();
		if ($_ =~ /^Chrom\t/) {
			push @outline, ('#Loc', 'Width', 'Band1', 'Band2');
			if ($mode eq 'cc_categ') {
				for (my $i=11; $i < $#temp-3; $i=$i+2) {
					my $statusname = $temp[$i];
					$statusname =~ s/\.Gain$/\.Status/;
					push @outline, ($statusname, @temp[$i..$i+1]);
				}
			}
			push @outline, @temp[-3..-1];
			push @BO, [@outline];
		}
		else {
			## Si la rÃ©gion est trop petite : goodbye...
			if ($temp[4] < $minprob) {
				next;
			}
			## Si la Pval brute est sous le seuil...
			if ( ($temp[-2] <= $thres) and ($temp[-2] ne 'NA') ) {
				
				$regz++;
				@outline = (join(':', $temp[0], join('-',  @temp[2,3])), ($temp[3]-$temp[2]+1), @temp[7,8]);
				if ($mode eq 'cc_categ') {
					for (my $i=11; $i < $#temp-3; $i=$i+2) {
						my $status = 'N';
						if ( ($temp[$i] >= $minfreq) and ($temp[$i+1] >= $minfreq) ) {
							$status = 'A';
						}
						elsif ( ($temp[$i] >= $minfreq) and ($temp[$i+1] < $minfreq) ) {
							$status = 'G';
						}
						elsif ( ($temp[$i] < $minfreq) and ($temp[$i+1] >= $minfreq) ) {
							$status = 'L';
						}
					
						push @outline, ($status, @temp[$i,$i+1]);
					}
				}
				push @outline, @temp[-3..-1];
				push @BO, [@outline];
				
			}
		}
	}
	close INDAT;
	
	my $outname = $outfile.'.mf'.$minfreq.'mp'.$minprob.'.R'.$regz.'.p'.$thres.'.txt';
	if ($mode eq 'cc_categ') {
		$outname = $outfile.'.CATEG.mf'.$minfreq.'mp'.$minprob.'.R'.$regz.'.p'.$thres.'.txt';
	}
	elsif ($mode eq 'cc_conti') {
		$outname = $outfile.'.CONTI.mp'.$minprob.'.R'.$regz.'.p'.$thres.'.txt';
	}

	open OUTDAT, ">".$outname or die $!;
	foreach my $l (0..$#BO) {
		print OUTDAT join("\t", @{$BO[$l]})."\n";
	}
	close OUTDAT;
	
	if ($grd eq 'Y') {
		print "Running grd to annotate the selected region ...\n";
		my $cmd = 'grd '.$outname.' -m '.$mode.' --sp '.$sp.' --gb '.$gb.' --ldb '.$ldb;
		print "CMD: $cmd \n";
		`$cmd`;
		print "Done.\n\n";
	}
}

