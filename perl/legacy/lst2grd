#!/usr/bin/perl
use strict;

my $version = '3.4b 20141117';

## VERSION NOTES
## +++++++++++++
##
## v3.5 20161207
##	. Replaced --proj and --db by --ldb to keep compatibility with grd.
##
## v3.4b 20141117
##	. Added support for rattus norvegicus (build rn4).
##
## v3.4 20140814
##	. Added multithreaded launch of grd using -n option.
##	. Changed option names to be more POSIX-compliant.
##
## v3.3b 20111220
##	. Corrected a bug which made the -gb option not working properly when set to non-default values.
##	. Cleaned up the help.
##
## v3.3 20111215
##	. Removed segments with normal status in the output, due to the new CBS "cut"
##	  structure created to support GISTIC formats in tabgen.
##	. Removed the last column, full of NAs, which was not taken in grd.
##	. Added missing '-proj' option required for grd.
##	. Same for '-db'.
##
## v3.2 20111213
##	. Renamed the script from 'lst2grdM' to 'lst2grd', as this script now calls the
##	  'grd' script to annotate the genomic content.
##	. Dropped support for log2(ratio) filtering and sorting.
##
## v3.1 20110831
##	. Modified the shebang, so that this script can be called from any unix system.
##	. Dropped support for hg17.
##	. Added support for mus msculus with build mm9.
##	. Dropped the '-chem' option, accordingly with genrdescM.
##
## v3.0 20100913
##	. New branch created from abr0togrdM to support the new LST format.
##

my $infile = '';
my $sp = 'hs';
my $gb = 19;
my $gcolstuff= '';
my $lcolstuff= '';
my $boldstuff= '';
my $ldb = '/mnt/data_cigogne/bioinfo/';
my $nt = 1;


if (scalar(@ARGV) == 0) {
	print '
LST2GRD v'.$version.'
 for: LST file to Genomic Regions Descriptor.

DESCRIPTION: This script launches grd for any sample found
 in a LST file given in input. Generated output files are
 output files generated by genrdesc used with the mode "solo".
 Please refer to the \'genrdescM\' script documentation.

USAGE:
 lst2grd [LST] --sp [hs|mm|rn] --gb [18|19|9|4] -g [float+] -l [float-] -b [float+] -n [int>0]

ARGUMENTS
	[LST]	A LST formatted file generated by tabgen.
	--sp	Species. ['.$sp.']
	--gb	Genome build. ['.$gb.']
	--ldb	A local data base. ['.$ldb.']
	-g	Positive log2(ratio) cut-off from which a coloration will
		be applied on gains. Default to values in grd script.
	-l	Negative log2(ratio) cut-off from which a coloration will
		be applied on losses. Default to values in grd script.
	-b	Positive log2(ratio) cut-off from which a bold effect will
		be applied on gains and losses. Default to values in grd script.
	-n	Number of threads for multithreaded run (only used if the LST
		contains results for more than one sample). ['.$nt.']
	
NOTE :	Please note that the \'grd\' script can only be called if its path is
	stored in the PATH variable environment...

';
exit;
}

## Gestion des paramï¿½tres;
else {
	$infile = $ARGV[0];
	foreach my $i (1..$#ARGV) {
		if ($ARGV[$i] =~ /^--sp$/)	{ $sp = $ARGV[$i+1]; }
		elsif ($ARGV[$i] =~ /^--gb$/)	{ $gb = $ARGV[$i+1]; }
		elsif ($ARGV[$i] =~ /^-g$/)	{ $gcolstuff = ' -g '.$ARGV[$i+1]; }
		elsif ($ARGV[$i] =~ /^-l$/)	{ $lcolstuff = ' -l '.$ARGV[$i+1]; }
		elsif ($ARGV[$i] =~ /^-b$/)	{ $boldstuff = ' -b '.$ARGV[$i+1]; }
		elsif ($ARGV[$i] =~ /^--ldb$/)	{ $ldb = $ARGV[$i+1];	}
		elsif ($ARGV[$i] =~ /^-n$/)	{ $nt = $ARGV[$i+1];	}
	}
}


## CHECK on species and genome build support
my %gvcheck = ( 'hg17' => 17, 'hg18' => 18, 'hg19' => 19, 'mm9' => 9, 'rn4' => 4);
my %spconv = ('hs' => 'hg', 'mm' => 'mm', 'rn' => 'rn');
my $gv = $spconv{lc($sp)}.$gb;
if (!exists $gvcheck{$gv}) {
	die "\nERROR : Unknown species or genome build !\n";
}
else { print "Working on ".$gv."\n"; }



##########
## CORE ##
##########

my %hash=();
open INF, $infile or die $!;
foreach (<INF>) {
	$_ =~ s/\n//;
	$_ =~ s/\r//;
	$_ =~ s/\ //g;
	if ($_ !~ /^Sample\t/) {
		my @temp = split /\t/, $_;
		my $status = '';
		if ($temp[11] > 0) { $status = 'G'; }
		if ($temp[11] < 0) { $status = 'L'; }
# 		if ($temp[11] == 0) { $status = 'N'; }
		if ($temp[11] == 0) { next; }
# 		push @{$hash{$temp[0]}}, [ (join(":", $temp[1], join("-", @temp[3,4])), $temp[5], $status, $temp[11], 2**$temp[11], 'NA') ];
		push @{$hash{$temp[0]}}, [ (join(":", $temp[1], join("-", @temp[3,4])), $temp[5], $status, $temp[11], 2**$temp[11]) ];
	}
}
close INF;

my @hks = keys(%hash);
my @ofiles = ();
foreach my $k (0..$#hks) {
	my $outfile = $hks[$k]."_solo.txt";
	push @ofiles, $outfile;
	my @temp = @{$hash{$hks[$k]}};
	open OUT, ">". $outfile or die $!;
	foreach my $l (0..$#temp) {
		print OUT join("\t", @{$temp[$l]})."\n";
	}
	close OUT;
}

if (scalar(@hks) < $nt) {
	$nt = scalar(@hks);
	print "\n".'Number of threads reduced to '.$nt.' ...';
}

if (($nt > 1) and (scalar(@ofiles) > 1)) {
	use Parallel::ForkManager;
	my $pm = new Parallel::ForkManager($nt);
	foreach my $k (@ofiles) {
		my $solocmd = 'grd --sp '.$sp.' --gb '.$gb.' --ldb '.$ldb.' -m solo'.$gcolstuff.$lcolstuff.$boldstuff.' '.$k;
		$pm->start and next;
		`$solocmd`;
		$pm->finish;
	}
	$pm->wait_all_children;
}
else {
	my $solocmd = 'grd --sp '.$sp.' --gb '.$gb.' --ldb '.$ldb.' -m solo'.$gcolstuff.$lcolstuff.$boldstuff.' \\*_solo.txt';
	print "CMD : ".$solocmd."\n";
	`$solocmd`;
}
