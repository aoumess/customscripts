## RSS SVD SCORER

## AUTHOR
## Bastien JOB (bastien.job@gustaveroussy.fr)

## DESCRIPTION
## This scripts performs :
## 1) A QN of a (prepared) poly-tumoral GEX dataset
## 2) A scaling of a synchronized cell line GEX profile
## 3) Build a set of pre-defined amount of Randomized Symbols Sets (RSSs)
## 4) Perform a context-similarity measurement of the cell-line and tumors for each of the RSSs
##    based on correlations in a specific SVD space.
## 5) Select RSS [v2 : depending on graphical criteria (closeness to given tumoral centroid, with
##    relative limits, distance to other centroids)].
## 6) Output the results.
##
## This script is part of my PhD project.
## It is a step-by-step version, ie one can re-work results from and to any step, as intermediate
## results are saved (as plain text, or Rdata).
## This version is multithreaded and works with data chunks.


## VERSION NOTES
##
## v4.0.0 201407    . New branch based on V2 1.2.1b (V3 does only exist as a test-version).
##                  . Changed data structure :
##                    - Now RSCs are generated by chunks of 1.0E+05 (user can't change this value).
##                    - If user requests (by ex) 1.0E+06 RSCs corresponding to a design for
##                      which (by ex) 2.5E+06 RSCs exist (ie, 250 chunks), the first 100 chunks
##                      whill be used. In the opposite, if only 6.0E+05 RSCs have been earlierly
##                      generated (60 chunks), the remaining 4.0E+05 missing chunks will be
##                      generated and the total 1.0E+06 used for firther steps.
##                    - Directory structure changed, taking into account the technology and design.
##                      This will avoid having a folder with RSC/SVD results of several different
##                      experiments mixed together (it happened for V2).
##                    - SVD results internal structure also changed : TO BE DEFINED.
##                  . Added adaptative selection of the number of dimensions :
##                    - By default, SVD is performed and limited to a number of dimensions set
##                      as 2x the number of pathologies in the tumoral dataset.
##                    - All SVDs are performed, then the number of dimensions is reduced to the
##                      number of dimensions that allow a coverage of at least 85% of the
##                      variance for at least 75% of the RSCs.
##                    - NOTA : THIS LAST CRITERION MAY BE CHANGE FOR ANOTHER ONE BASED ON CENTROIDS
##                      COORDINATES *NOT* MOVING IN FURTHER DIMENSIONS...
##                  . Dismissed the graphical selection criterion to a clustering-based one :
##                    - For each RSC, the distance of the tested CL to each centroid is kept.
##                    - Consequently, the results consists in a distance matrix of n RSCs x p
##                      pathologies, on which a clustering method can be applied (TO BE DEFINED)
##                    - On this clustering, the cluster regrouping the RSCs for which the distances
##                      to the target pathology are the lowest ones can be kept.
##                    - Fisher enrichment test can then be performed on these selected RSCs.
##
## v1.2.1b 20140703 . Tested on CH3 without further modification.
##                  . Corrected a bug in the coloring of boxplots (added an unlist()).
##
## v1.2.1 20140606  . Added support for CGH
##
## v1.2.0 20140319  . Wrapped the main code loop into a function.
##                  . Changed some structure parts to allow MIR data support.
##                  . Added stronger checks on RSS-SVD data (problematic when switching from a design to
##                    another one, giving a final list of entities with varying composition).
##                  . Resolved a bug forcing ndim to lower to the value of rdm.size when rdm.size < ndim.
## v1.1   20140207  . Changed correlation computation so that they are performed using matrices instead of
##                    dumb loops. Should dramatically improve computation times (tests, soon!).
##                  . Corrected a bug which made the script break if the routine doesn't find any relevant
##                    RSS in a chunk.
##                  . Corrected another bug which made the script break at the plotting of relevant genes
##                    boxplots across pathologies, when no relevant gene was found.
## v1.0   20130601  . First life-working release.

setwd("/run/media/job/Noir/V2/BB_Score_cells")
setwd("G:/V2/BB_Score_cells")


# library(impute)
library(snowfall)
library(limma)


#########################
## INIT TEST VARIABLES ##
#########################


# target.patho <<- "MM"
# target.patho <<- "MEL-MM"
# rdm.size <- 20
# nthrow <- 1.00E+06
# chunksize <- 1.00E+05
# cor.meth <- "pearson"
# target.scormin <- 1.0
# range.scormin <- 2.0
# ncores <- 5
# # cl.rootname <<- "MCL"
# # dimlim <- 16
# # tum.rdata <- "Data/GEX/TUM/NBL+MM+OVA+EWS+COL+BRE+LUN+LIV_20131030150238.Rdata"
# tum.rdata <- "Data/MIR/TUM/Data_COL.TUM+LUN-TUM+OVA-TUM+GBM-TUM+MEL-MM+LIV-TUM+EWS-TUM+BRE-TUM_20140318144101.Rdata"
# make.plots=T



###############
## FUNCTIONS ##
###############

## RSSs (randomized symbols sets) GENERATOR
rssgen2 <- function(values, nchunks=100, npop=10, path, chunkstart=1) {
  
  ## Building the RSS-CHECK object if chunkstart == 1
  if (chunkstart == 1) saveRDS(rss.chk, file=paste(path, "/rss.chk.RDS", sep=""))
  rm(rss.chk)
  idx <- 1:length(values)
  nb.chk <- nthrow/chkz
  sapply(1:nb.chk, function(c) {
    tmp.smp <- t(replicate(chkz, sample(idx, npop)))
    tmp.smb <- matrix(values[tmp.smp], nrow=nrow(tmp.smp), byrow=F)
    write.table(tmp.smp, paste(path, "/RSS/", paste("RSS", sprintf("%E",chkz), npop, length(values), "INDEX", "chunk", sep="_"), sprintf("%.2d", c), ".txt", sep=""), sep="\t", quote=F, row.names=F, col.names=F)
    write.table(tmp.smb, paste(path, "/RSS/", paste("RSS", sprintf("%E",chkz), npop, length(values), "SYMBOL", "chunk", sep="_"), sprintf("%.2d", c), ".txt", sep=""), sep="\t", quote=F, row.names=F, col.names=F)
    return()
  })
}

## Additional functions for features merging
source("~/svn/genomics/utils/R/rowcolfuncs.R")
source("G:/V2/rowcolfuncs.R")

## SCORER
go.scorer <- function(cl.list, target.patho, rdm.size, nthrow, chunksize, cor.meth, target.scormin, range.scormin, ncores, tum.rdata, norm=T, make.plots) {
  
  for(cl.file in cl.list) {
    
    ## Loading the CL
    cat("Loading SINGLE", cl.file, "...\n")
    clori <- read.table(cl.file, header=T, sep="\t", check.names=F, as.is=T)
    
    ## Loading the TUM set
    cat("Loading TUMORS", tum.rdata, "...\n")
    load(tum.rdata)
    ## Checking if requested pathology is available
    if(!(target.patho %in% tumori$dtypes)) stop("Target pathology ", target.patho, " could not be found!\n")
    ndim <- length(tumori$dtypes)
    if(rdm.size < ndim) ndim <- rdm.size
    
    ## Synching
    clori <- clori[which(clori$Symbol %in% rownames(tumori$data)),]
    tumori$data <- tumori$data[which(rownames(tumori$data) %in%clori$Symbol),]
    
    if(!unique(rownames(tumori$data) == clori$Symbol)) stop("ERROR !!! EVERYTHING BELOW WILL BE WRONG")
    
    ## Creating output structure
    resdir <- "Results"
    interdatadir <- "Data_intermediary"
    plotdir <- "Plots"
    scordir <- "Score_table"
    otherdir <- "Other_tables"
    strucdir <- paste(interdatadir, paste(sprintf("%E",nthrow), sprintf("%E",chunksize), rdm.size, nrow(clori), sep="_"), sep="/")
    stresdir <- paste(resdir, paste(target.patho, sprintf("%E",nthrow), rdm.size, nrow(clori), sep="_"), sep="/")
    dir.create(paste(strucdir, "RSS", sep="/"), recursive=T)
    dir.create(paste(strucdir, "SVD", sep="/"), recursive=T)
    dir.create(paste(stresdir, plotdir, sep="/"), recursive=T)
    dir.create(paste(stresdir, scordir, sep="/"), recursive=T)
    dir.create(paste(stresdir, otherdir, sep="/"), recursive=T)
    
    
    ## Raw plots
    if (make.plots) {
      xmat <- cbind(clori[,2], tumori$data)
      colnames(xmat)[1] <- colnames(clori)[2]
      png(paste(stresdir, "/", colnames(clori)[2], "_raw_boxplots.png", sep=""), 1280, 800)
      boxplot(xmat, col=c(0, unlist(as.vector(sapply(1:length(tumori$dt.idx), function(p) { rep.int(p,length(tumori$dt.idx[[p]])) } )))))
      dev.off()
      png(paste(stresdir, "/", colnames(clori)[2], "_raw_hclust.png", sep=""), 1280, 800)
      plot(hclust(dist(t(xmat), method="euclidean"), method="ward"))
      dev.off()
    }
    
    if (norm) {
      ## QN on tumors
      tumori$data <- normalizeQuantiles(tumori$data)
      
      ## Normalization for the CL (retrieval of )
      clori$Rank <- rank(clori[,2])
      clori <- clori[order(clori$Rank),]
      clori[,2] <- tumori$data[order(tumori$data[,1]),1]
      clori <- clori[order(clori$Symbol),]
      write.table(clori, paste(stresdir, "/", otherdir, "/", colnames(clori)[2], "_NormExp", ".txt", sep=""), sep="\t", quote=F, row.names=F)
      
      ## NORM plots
      if (make.plots) {
        xmat <- cbind(clori[,2], tumori$data)
        colnames(xmat)[1] <- colnames(clori)[2]
        png(paste(stresdir, "/", colnames(clori)[2], "_norm_boxplots.png", sep=""), 1280, 800)
        boxplot(xmat, col=c(0, unlist(as.vector(sapply(1:length(tumori$dt.idx), function(p) { rep.int(p,length(tumori$dt.idx[[p]])) } )))))
        dev.off()
        png(paste(stresdir, "/", colnames(clori)[2], "_norm_hclust.png", sep=""), 1280, 800)
        plot(hclust(dist(t(xmat), method="euclidean"), method="ward"))
        dev.off()
        rm(xmat)
      }
      gc()
    } else {
      file.copy(from=cl.file, paste(stresdir, "/", otherdir, sep=""))
    }
    
    ## Checking if RSSs are already there
    cat("Checking RSS chunks availability ...\n")
    rss.chk.find <- dir(strucdir, "rss.chk.RDS")
    if(length(rss.chk.find) == 1) {
      cat("Found putative compatible RSS set ...\n")
      rss.chk <- readRDS(paste(strucdir, "/rss.chk.RDS", sep=""))
      str(rss.chk)
      str(list(VALUES=sort(clori$Symbol), NTHROW=nthrow, CHUNKSIZE=chunksize, NPOP=rdm.size))
      if( (length(rss.chk$values) != nrow(clori)) | (length(unique(rss.chk$values == sort(clori$Symbol))) > 1) | (unique(rss.chk$values == sort(clori$Symbol))==F) | (rss.chk$nthrow != nthrow) | (rss.chk$chunksize != chunksize) | (rss.chk$npop != rdm.size)) {
        write.table(rss.chk$values, "rss.chk.values.txt", row.names=F, sep="\t", quote=F)
        write.table(sort(clori$Symbol), "clori.values.txt", row.names=F, sep="\t", quote=F)
        stop("\n\nAPOPOCALYPSE!\n\n")
      }
#       if( (length(rss.chk$values) != nrow(clori)) || (length(unique(rss.chk$values == sort(rownames(clori)))) > 1) || (unique(rss.chk$values == sort(rownames(clori)))==F) || (rss.chk$nthrow != nthrow) || (rss.chk$chunksize != chunksize) || (rss.chk$npop != rdm.size)) stop("\n\nAPOPOCALYPSE!\n\n")
    }
    
    ## Generating the RSSs if required
#     rss.idx.list <- dir("Data_intermediary/RSS/",         paste("^RSS_", sub("\\+", "\\\\+",             chunksize), "\\.", rdm.size, ".*_INDEX_chunk.*\\.txt$", sep=""), full.names=T)
    rss.idx.list <- dir(paste(strucdir, "/RSS/", sep=""), paste("^RSS_", sub("\\+", "\\\\+", sprintf("%E",chunksize)), "_", rdm.size, ".*_INDEX_chunk.*\\.txt$", sep=""), full.names=T)
    if(length(rss.idx.list) == 0) {
      cat("Did not find proper RSS chunks, generating them ...\n")
      rssgen2(values=rownames(tumori$data), nthrow=nthrow, chkz=chunksize, npop=rdm.size, path=strucdir)
#       rss.idx.list <- dir("Data_intermediary/RSS/", paste("^RSS_", sub("\\+", "\\\\+", chunksize), "\\.", rdm.size, ".*_INDEX_chunk.*\\.txt$", sep=""), full.names=T)
      rss.idx.list <- dir(paste(strucdir, "/RSS/", sep=""), paste("^RSS_", sub("\\+", "\\\\+", sprintf("%E",chunksize)), "_", rdm.size, ".*_INDEX_chunk.*\\.txt$", sep=""), full.names=T)
    }
#     rss.smb.list <- dir("Data_intermediary/RSS/", paste("^RSS_", sub("\\+", "\\\\+", chunksize), "\\.", rdm.size, ".*_SYMBOL_chunk.*\\.txt$", sep=""), full.names=T)
    rss.smb.list <- dir(paste(strucdir, "/RSS/", sep=""), paste("^RSS_", sub("\\+", "\\\\+", sprintf("%E",chunksize)), "_", rdm.size, ".*_SYMBOL_chunk.*\\.txt$", sep=""), full.names=T)
    
    ## Building pure-tumoral SVD spaces (if they do not exist) by chunks
#     coords.list <- dir("Data_intermediary/SVD/", "^SVD_COORDS_.*\\.Rdata$", full.names=T)
    coords.list <- dir(paste(strucdir, "/SVD/", sep=""), "^SVD_COORDS_.*\\.Rdata$", full.names=T)
    if(length(coords.list) == 0) {
      sfStop()
      sfInit(parallel=T,cpus=ncores)
      sfExport("tumori", "clori", "ndim", "rss.idx.list", "cor.meth")
      sfSapply(1:length(rss.idx.list), function(rchunk) {
        my.rss <- as.matrix(read.table(rss.idx.list[rchunk], header=F, sep="\t"))
        if(max(my.rss) != nrow(clori)) stop(paste("\n\nERROR : Cell line has ", nrow(clori), " features, but RSS chunks max is ", max(my.rss), " !!\n\n", sep=""))
        coords <- sapply(1:nrow(my.rss), function(r) {
          sub.tu <- tumori$data[my.rss[r,],]
          pca.res <- prcomp(t(sub.tu), center=T)
          #         pca.res <- prcomp(t(sub.tu), center=F)
          space.lim <- pca.res$rotation[,1:ndim]
          varvec <- pca.res$sdev^2
          varcum <- round(cumsum(varvec)/sum(varvec), digits=2)
          cormat <- t(cor(sub.tu, space.lim, method=cor.meth))
          centerz <- t(sapply(1:length(tumori$dtypes), function(c) { return( rowMeans(cormat[, tumori$dt.idx[[c]]]) ) }))
          rownames(centerz) <- tumori$dtypes
          colnames(centerz) <- colnames(space.lim)
          return(list(space=space.lim, varcum=varcum[1:ndim], centroids=centerz))
        }, simplify=F)
        names(coords) <- paste("RSS", 1:length(coords))
#         save(coords, file=paste("Data_intermediary/SVD/SVD_COORDS_", paste(sprintf("%.1e", nrow(my.rss)), ncol(my.rss), ndim, nrow(clori), sep="."), "_chunk", sprintf("%.2d", rchunk), ".Rdata", sep=""))
        save(coords, file=paste(strucdir, "/SVD/SVD_COORDS_", paste(sprintf("%E", nrow(my.rss)), ncol(my.rss), ndim, nrow(clori), sep="."), "_chunk", sprintf("%.2d", rchunk), ".Rdata", sep=""))
        return()
      })
      sfStop()
#       coords.list <- dir("Data_intermediary/SVD/", "^SVD_COORDS_.*\\.Rdata$", full.names=T)
      coords.list <- dir(paste(strucdir, "/SVD/", sep=""), "^SVD_COORDS_.*\\.Rdata$", full.names=T)
    }
    
    ## Scoring the cell ** V2B **
    
    cat("Go for cell line", colnames(clori)[2],"\n")
    cat("Injecting cell line ...\n")
    sfStop()
    sfInit(parallel=T,cpus=ncores)
    sfExport("coords.list", "rss.idx.list", "rss.smb.list", "clori", "target.patho", "ndim", "tumori", "target.scormin", "range.scormin")
    ## Looping on the SVD Rdata files
    bbg <- sfSapply(1:length(coords.list), function(rc) {
      ## Loading RSS and SVD chunks
      rss.idx.rc <- as.matrix(read.table(rss.idx.list[rc], sep="\t", header=F, as.is=T))
      rss.smb.rc <- as.matrix(read.table(rss.smb.list[rc], sep="\t", header=F, as.is=T))
      load(coords.list[rc])
      ## Looping on RSSs
      biggy <- t(sapply(1:length(coords), function(r) {
        ## Subsetting the cell line expression
        sub.mcl <- clori[rss.idx.rc[r,],2]
        
        cl.coords <- cor(sub.mcl, coords[[r]]$space)
        
        ## Correlation to eigensamples
        #       cl.coords <- sapply(1:ndim, function(e) {
        #         cor(sub.mcl, coords[[r]]$space[,e])
        #       })
        
        ## Computing CL distances to centroids
        cl.dist <- sapply(1:nrow(coords[[r]]$centroids), function(p) {
          sqrt(sum((coords[[r]]$centroids[p,1:ndim] - cl.coords[1:ndim])^2))
        })
        ## Computing TARGET distances to other centroids
        target.idx <- which(rownames(coords[[r]]$centroids) == target.patho)
        range.dist <- sapply(1:nrow(coords[[r]]$centroids), function(p) {
          sqrt(sum((coords[[r]]$centroids[p,1:ndim] - coords[[r]]$centroids[target.idx,1:ndim])^2))
        })
        
        ## Computing CL to target score
        names(cl.dist) <- tumori$dtypes
        cl.dist.ord <- cl.dist[order(cl.dist)]
        cl.ordernames <- attributes(cl.dist.ord)$names
        cl.do2 <- cl.dist.ord[-c(which(attributes(cl.dist.ord)$names == target.patho))]
        cl.score <- cl.do2[1] / cl.dist[which(tumori$dtypes == target.patho)]
        names(cl.score) <- "Target.score"
        
        ## Computing range score
        range.score <- min(range.dist[-c(target.idx)]) / cl.dist[which(tumori$dtypes == target.patho)]
        names(range.score) <- "Range.score"
        
        return(c(cl.ordernames[1], cl.score, range.score, coords[[r]]$varcum[1], coords[[r]]$varcum[ndim]))
      }, simplify=T))
      
      biggy <- as.data.frame(biggy, stringsAsFactors=F)
      colnames(biggy) <- c("Closest.centroid", "Target.score", "Range.score", "Var.E1", paste("Var.cum.dim.", ndim, sep=""))
      rownames(biggy) <- paste("RSS.", seq.int(1:nrow(biggy)), sep="")
      
      ## RSS selection with a defined criterion (see variables in the upper part)
      cat("RSS selection ...\n")
      goodrss <- which((biggy$Closest.centroid == target.patho) & (biggy$Target.score > target.scormin) & (biggy$Range.score > range.scormin))
      biggy2 <- biggy[goodrss,]
      
      ## Symbols global occurrence
      cat("Counting global occurrences ...\n")
      soccz <- as.data.frame(table(rss.smb.rc), stringsAsFactors=F)
      gc()
      colnames(soccz) <- c("Symbol", "Freq")
      soccz <- soccz[order(soccz$Symbol),]
      
      ## Symbols occurrence for selection
      if (length(goodrss > 0)) {
        cat("Counting occurrences in selection ...\n")
        soccz2 <- as.data.frame(table(rss.smb.rc[goodrss,]), stringsAsFactors=F)
        gc()
        colnames(soccz2) <- c("Symbol", "Freq")
        soccz2 <- soccz2[order(soccz2$Symbol),]
      } else {
        soccz2 <- as.data.frame(matrix(ncol=2, nrow=0))
        colnames(soccz2) <- c("Symbol", "Freq")
      }
      return(list(score.all=biggy, score.sel=biggy2, freq.all=soccz, freq.sel=soccz2))
    }, simplify=F)
    
    
    ## Reunifying the tables
    cat("Scoring!\n")
    score.all <- matrix(ncol=ncol(bbg[[1]]$score.all),  nrow=0)
    score.sel <- matrix(ncol=ncol(bbg[[1]]$score.sel),  nrow=0)
    freq.tab <- data.frame(Symbol=sort(rownames(tumori$data)), Freq.all=0, Freq.sel=0, stringsAsFactors=F)
    freq.all.len <- 0
    freq.sel.len <- 0
    for (ch in 1:length(bbg)) {
      score.all <- rbind(score.all, as.matrix(bbg[[ch]]$score.all))
      score.sel <- rbind(score.sel, as.matrix(bbg[[ch]]$score.sel))
      mys1 <- which(freq.tab$Symbol %in% bbg[[ch]]$freq.all$Symbol)
      freq.tab$Freq.all[mys1] <- freq.tab$Freq.all[mys1] + bbg[[ch]]$freq.all$Freq
      mys2 <- which(freq.tab$Symbol %in% bbg[[ch]]$freq.sel$Symbol)
      freq.tab$Freq.sel[mys2] <- freq.tab$Freq.sel[mys2] + bbg[[ch]]$freq.sel$Freq
      freq.all.len <- freq.all.len + nrow(bbg[[ch]]$score.all)
      freq.sel.len <- freq.sel.len + nrow(bbg[[ch]]$score.sel)
    }
    ## Dumping score.all
    write.table(score.all, paste(stresdir, "/", otherdir, "/", colnames(clori)[2], "_all.scores_", sprintf("%.1e", nthrow), ".", rdm.size, ".", ndim, ".txt", sep=""), sep="\t", quote=F, row.names=F)
    
    ## Distribution of best pathologies
    bestp <- as.data.frame(table(score.all[,1]))
    colnames(bestp) <- c("Closest.centroid", "Occ")
    bestp$Freq <- bestp$Occ / sum(bestp$Occ)
    bestp <- bestp[order(bestp$Closest.centroid),]
    write.table(bestp, paste(stresdir, "/", otherdir, "/", colnames(clori)[2], "_best.centroids_", sprintf("%.1e", nthrow), ".", rdm.size, ".", ndim, ".txt", sep=""), sep="\t", quote=F, row.names=F)
    
    ## Fisher's Exact test for enrichment
    freq.tab$RSS.all <- freq.all.len
    freq.tab$RSS.sel <- freq.sel.len
    sfStop()
    sfInit(parallel=T,cpus=ncores)
    sfExport(list=c("freq.tab", "freq.all.len", "freq.sel.len", "nthrow"))
    freq.tab$F.raw.p <- sfSapply(1:nrow(freq.tab), function(x) {
      return(fisher.test(matrix(c(freq.tab$Freq.all[x], nthrow, freq.tab$Freq.sel[x], freq.sel.len), 2, 2), alternative="less")$p.value)
    })
    sfStop()
    freq.tab$F.BH.adj.p <- p.adjust(freq.tab$F.raw.p, method="BH")
    
    freq.tab <- freq.tab[order(freq.tab$F.BH.adj.p, freq.tab$F.raw.p, freq.tab$Freq.sel, freq.tab$Freq.all/freq.tab$Freq.sel),]
    
    ## Dumping results table
    write.table(freq.tab, paste(stresdir, "/", scordir, "/", colnames(clori)[2], "_SCORED_", sprintf("%.1e", nthrow), ".", rdm.size, ".", ndim, ".txt", sep=""), sep="\t", quote=F, row.names=F)
    
    ## GEX plot for significant symbols
    sigs <- freq.tab$Symbol[which(freq.tab$F.BH.adj.p < 5.0E-02)]
    pdf(paste(stresdir, "/", plotdir, "/", colnames(clori)[2], "_GEXPLOTS_", sprintf("%.1e", nthrow), ".", rdm.size, ".", ndim, ".pdf", sep=""), width=29.7/cm(1), height=21/cm(1))
    if (length(sigs) > 0) {
      for (sidx in 1:length(sigs)) {
        snam <- freq.tab$Symbol[sidx]
        s <- which(rownames(tumori$data) == snam)
        svalz <- list()
        for(p in tumori$dtypes) {
          svalz[[p]] <- tumori$data[s, tumori$dt.idx[[p]]]
        }
        boxplot(svalz, main=paste(snam, "\np = ", sprintf("%.3e", freq.tab$F.BH.adj.p[sidx]), sep=""), ylim=range(c(svalz, clori[s,2])))
        points(which(tumori$dtypes == target.patho), clori[s,2], col=2, pch=4)
      }
    } else plot(0,0, cex=3, pch=4, col=2, main="NO SYMBOL FOUND")
    dev.off()
    
    gc()
  }
}



##########
## CORE ##
##########

go.scorer(
  cl.list=dir("Data/MIR/CL/P19_AS_MCL/", "*\\.txt$", full.names=T),
  target.patho="MEL.MM",
  rdm.size=20,
  nthrow=1.00E+06,
  chunksize=1.00E+05,
  cor.meth="pearson",
  target.scormin=1.0,
  range.scormin=2.0,
  ncores=5,
  tum.rdata="Data/MIR/TUM/Data_LIV.TUM+BRE.TUM+OVA.TUM+EWS.TUM+LUN.TUM+COL.TUM+MEL.MM+GBM.TUM_20140326110014.Rdata",
  make.plots=F
)

## sandbox WIN
go.scorer(
  cl.list=dir("G:/V2/BA_Prepare_CL_dataset/Results/GEX_SANDBOX/HAWARD_MEL.CL/subsel", "*\\.txt$", full.names=T),
  target.patho="MEL.MM",
  rdm.size=20,
  nthrow=1.00E+06,
  chunksize=1.00E+05,
  cor.meth="pearson",
  target.scormin=1.0,
  range.scormin=2.0,
  ncores=7,
  tum.rdata="G:/V2/AB_Prepare_TUM_dataset/Results/GEX_SANDBOX_4PATHOS/Data_MEL.MM.44+EWS.TUM.117+GBM.TUM.45+NBL.TUM.88_20140421180936.Rdata",
  make.plots=F
)

## sandbox WIN (9 pathologies)
go.scorer(
#   cl.list=dir("G:/V2/BA_Prepare_CL_dataset/Results/GEX_SANDBOX/HAYWARD_MEL.CL/subsel", "*\\.txt$", full.names=T),
#   cl.list=dir("G:/V2/BA_Prepare_CL_dataset/Results/GEX_SANDBOX/NOTAS_LIV.CLT", "*\\.txt$", full.names=T),
#   cl.list=dir("G:/V2/BA_Prepare_CL_dataset/Results/GEX_SANDBOX/VOICKMANN_NBL.CL", "*\\.txt$", full.names=T),
#   cl.list=dir("G:/V2/BA_Prepare_CL_dataset/Results/GEX_SANDBOX/MOK_OVA.CLT", "*\\.txt$", full.names=T),
#   cl.list=dir("G:/V2/BA_Prepare_CL_dataset/Results/GEX_SANDBOX/NCI60_OVA.CL", "*\\.txt$", full.names=T),
#   cl.list=dir("G:/V2/BA_Prepare_CL_dataset/Results/GEX_SANDBOX/QIN_OVA.CLT", "*\\.txt$", full.names=T),
#   cl.list=dir("G:/V2/BA_Prepare_CL_dataset/Results/GEX_SANDBOX/TAN_OVA.CL", "*\\.txt$", full.names=T),
#   cl.list=dir("G:/V2/BA_Prepare_CL_dataset/Results/GEX_SANDBOX/NCI60_BRE.CL", "*\\.txt$", full.names=T),
#   cl.list=dir("G:/V2/BA_Prepare_CL_dataset/Results/GEX_SANDBOX/NCI60_COL.CL", "*\\.txt$", full.names=T),
#   cl.list=dir("G:/V2/BA_Prepare_CL_dataset/Results/GEX_SANDBOX/NCI60_LUN.CL", "*\\.txt$", full.names=T),
#   cl.list=dir("G:/V2/BA_Prepare_CL_dataset/Results/GEX_SANDBOX/NCI60_MEL.CL", "*\\.txt$", full.names=T),
  cl.list=dir("/run/media/job/Noir/V2/BA_Prepare_CL_dataset/Results/GEX_SANDBOX/NCI60_MEL.CL", "*\\.txt$", full.names=T),
  target.patho="MEL.MM",
#   target.patho="LIV.TUM",
#   target.patho="NBL.TUM",
#   target.patho="OVA.TUM",
#   target.patho="BRE.TUM",
#   target.patho="COL.TUM",
#   target.patho="LUN.TUM",
  rdm.size=20,
  nthrow=3.00E+05,
  chunksize=3.00E+04,
  cor.meth="pearson",
  target.scormin=1.0,
  range.scormin=2.0,
  ncores=5,
#   tum.rdata="G:/V2/AB_Prepare_TUM_dataset/Results/GEX_SANDBOX_9PATHOS/Data_MEL.MM.44+LIV.TUM.91+OVA.TUM.58+LUN.TUM.58+BRE.TUM.40+EWS.TUM.44+COL.TUM.62+GBM.TUM.45+NBL.TUM.88_20140422001512.Rdata",
  tum.rdata="/run/media/job/Noir/V2/AB_Prepare_TUM_dataset/Results/GEX_SANDBOX_9PATHOS/Data_MEL.MM.44+LIV.TUM.91+OVA.TUM.58+LUN.TUM.58+BRE.TUM.40+EWS.TUM.44+COL.TUM.62+GBM.TUM.45+NBL.TUM.88_20140422001512.Rdata",
  make.plots=F
)

## GEX classic
go.scorer(
  cl.list=dir("/run/media/job/Noir/V2/BA_Prepare_CL_dataset/Results/GEX/HAYWARD_MM63/tests", "*\\.txt$", full.names=T),
  target.patho="MM",
  rdm.size=20,
  nthrow=1.00E+06,
  chunksize=1.00E+05,
  cor.meth="pearson",
  target.scormin=1.0,
  range.scormin=2.0,
  ncores=5,
  tum.rdata="/run/media/job/Noir/V2/AB_Prepare_TUM_dataset/Results/GEX/Data_NBL+MM+OVA+EWS+COL+BRE+LUN+LIV_20131030151530.Rdata",
  make.plots=F,
  norm=T
)


## CGH test
go.scorer(
  cl.list=dir("/run/media/job/Noir/V2/AB_Prepare_TUM_dataset/Results/CGH/CELL-LINES/mpNA_cr1.0/test/", "^MCL_.*\\.txt$", full.names=T),
  target.patho="MEL",
  rdm.size=75,
  nthrow=1.00E+06,
  chunksize=1.00E+05,
  cor.meth="pearson",
  target.scormin=1.0,
  range.scormin=2.0,
  ncores=5,
  tum.rdata="/run/media/job/Noir/V2/AB_Prepare_TUM_dataset/Results/CGH/BLA60+COL16+MED24+MEL37+PGL38+SAL18_hg19_noX_noY_mpNA_cr1.Rdata",
  make.plots=F,
  norm=F
)


## CH3 test
go.scorer(
  cl.list=dir("/run/media/job/Noir/V2/BA_Prepare_CL_dataset/Results/CH3/RYU_MEL.CL11/", "^GSM.*\\.txt$", full.names=T),
  target.patho="MEL.PM",
  rdm.size=50,
  nthrow=1.00E+06,
  chunksize=1.00E+05,
  cor.meth="pearson",
  target.scormin=1.0,
  range.scormin=2.0,
  ncores=5,
  tum.rdata="/run/media/job/Noir/V2/AB_Prepare_TUM_dataset/Results/CH3_test4/Data_OVA.TUM.25+GBM.TUM.25+MEL.PM.24+NBL.TUM.25+BRE.TUM.25+COL.TUM.25+LUN.TUM.25_20140703171202.Rdata",
  make.plots=T,
  norm=T
)