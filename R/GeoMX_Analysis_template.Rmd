---
title: "BIGRCODE GeoMX RTxxx.xx ANALYSIS (RNA)"
author: "Firstname LASTNAME<BR>anyone@gustaveroussy.fr"
date: "`r format(Sys.time(), '%Y/%m/%d')`"
output:
  html_document: 
    background: black
    fig_height: 10
    fig_width: 15
    highlight: tango  ## Theme for the code chunks
    number_sections: true  ## Adds number to headers (sections)
    theme: flatly  ## CSS theme for the HTML page
    toc: true  ## Adds a table of content
    toc_float:  ## TOC options
      collapsed: true  ## By default, the TOC is folded
    smooth_scroll: true ## Smooth scroll of the HTML page
    self_contained: true ## Includes all plots/images within the HTML
    code_download: true ## Adds a button to download the Rmd
    code_folding: show
    thumbnails: false
    lightbox: true
    fig_caption: false
    gallery: true
    use_bookdown: true
always_allow_html: true ## Allow plain HTML code in the Rmd
---

# Working environment setup

## Variables

```{r setup_var, message = FALSE}

## DIRECTORIES / INPUT FILES

### DIR : Main rootname (project dir that contains QC subdir)
root_dir <- '~'
root_dir <- '/home/job/WORKSPACE/PROJECTS/B24012_GAMO_01_Gabriel.MORIN_GeoMX_RT180.23/RESULTS/B24012_GAMO_01_RT180.23_GeoMx_RNA_20240313211310'

### INPUT : RDS object generated by the GeoMX_QC_template.Rmd (a DESeq2 object that contains raw expression data, after outlier removal)
input_RDS <- ''
input_RDS <- '/home/job/WORKSPACE/PROJECTS/B24012_GAMO_01_Gabriel.MORIN_GeoMX_RT180.23/RESULTS/B24012_GAMO_01_RT180.23_GeoMx_RNA_20240313211310/QC/Raw_outlier.filtered_67s.RDS'

### INPUT : Optional additional sample annotation (MS XLSX) file path. It has to be synched (same length, same sample names, same order) with the annotations from the DSP output, and first column has to be the same as this output column "SegmentDisplayName". Keep as NULL if no file to provide
annot_filename <- NULL
annot_filename <- '/home/job/WORKSPACE/PROJECTS/B24012_GAMO_01_Gabriel.MORIN_GeoMX_RT180.23/gitlab/b24012_gamo_01/data_input/GAMO_WTA_RNA_annotation.xlsx'

### Analysis tag name
analysis_name <- 'DEA'

### ANNOTATION : sample names column
annot_sn <- 'SegmentDisplayName'


## OTHER PARAMETERS

### LIST of CATEGORICAL/DISCRETE data types to enlight (by split/coloring) in plots, and assess as covariates. Keys are displayed names, values are annotation table column names
# box_categ <- list(
#   'Cell Type' = 'SegmentLabel'
#   , 'Slide' = 'SlideName'
#   , 'Batch' = 'Batch'
#   , 'ROI' = 'ROILabel'
#   , 'AOI' = 'AOILabel'
#   , 'Epiderme' = 'Epiderme'
#   , 'Cellules endotheliales' = 'Cellules endotheliales'
#   , 'Leucocytes' = 'Leucocytes'
#   , 'ROI Comments' = 'ROIComments'
# )

## No special character allowed !!
box_categ <- list(
  'Cell Type' = 'SegmentLabel'
  , 'Cell_marker' = 'Cell_marker'
  , 'BIO_ID' = 'BIO_ID'
  , 'Patient ID' = 'Patient_ID'
  , 'Pre/Post' = 'PrePost'
  , 'Slide' = 'SlideName'
  , 'Batch' = 'Batch'
  , 'ROI' = 'ROILabel'
  , 'AOI' = 'AOILabel'
  , 'Epiderme' = 'Epiderme'
  , 'Cellules endotheliales' = 'Cellules endotheliales'
  , 'Leucocytes' = 'Leucocytes'
  , 'ROI Comments' = 'ROIComments'
  , 'Pre/Post in CD31' = 'PrePost_in_CD31'
  , 'Pre/Post in CD31+CD45' = 'PrePost_in_CD31.CD45'
  , 'Pre/Post in CD31 and CD31+CD45' = 'PrePost_in_CD31_CD31.CD45'
  , 'Pre/Post in Endothelial' = 'PrePost_in_Endothelial'
  , 'Pre/Post in Leucocyte' = 'PrePost_in_Leucocyte'
  , 'Pre/Post in Endothelial and Leucocyte' = 'PrePost_in_Endothelial_Leucocyte'
  , 'Pre/Post in Epidermis' = 'PrePost_in_Epidermis'
  
)

### VECTOR of annotation column names to assess as putative CONTINUOUS covariates. (this should be changed to a list in further updates, in sake of homogeneity with box_categ) Default are common ones for GeoMX RNA.
conti_categ <- c(
  'AOISurfaceArea'
  , 'AOINucleiCount'
  , 'StitchedReads'
  , 'SequencingSaturation'
)

### Vector of annotation column names to use as CATEGORICAL variables for differential expression analysis.
diff_categ <- c(
  'PrePost_in_Endothelial'
  , 'PrePost_in_Leucocyte'
  , 'PrePost_in_Epidermis'
  , 'PrePost_in_Endothelial_Leucocyte'
)

### List of COVARIATES (categorical a/o continuous) to use to generate the default DEA design matrix. This is a list of the same size as diff_categ, and synched with it, which contains character vectors naming the covariate(s) to use. Set NULL when no covariate regression is requested
covariates <- list(
  c('SlideName')
  , c('SlideName')
  , c('Patient_ID')
  , c('SegmentLabel', 'SlideName')
)


## BASIC PARAMETERS

### Species name (needed for GSEA/ORA/GSVA to transpose symbols to ENTREZ)
species = 'Homo sapiens'
### Number of max different distant colors to generate in the RGB space, for boxplots/PCAs (should cover all possible classes in any of the requested annotation)
ncolors <- 20
### Fixing seed
my_seed <- 1337
### DESeq2 normalization method (only VST supported yet)
norm_method <- 'vst'
### Top variant genes to use for PCA
topvar <- 500
### Significance threshold
adjp.max <- 5E-02
### Minimum absolute log2FoldChange threshold
lfc.min <- 0
## Types of distance to clusterize samples
samples_dist_method <- c(
  'spearman'
  , 'manhattan'
  , 'euclidean'
)
## Minimum term length to perform GSEA/ORA
enr_min_genes <- 10
## GSEA DBs
### MSigDB
msigdb.do.tmp <- c(TRUE, TRUE)
msigdb.collec <- as.data.frame(msigdbr::msigdbr_collections())
msigdb.collec <- msigdb.collec[grep(pattern = '(GO:|REACTOME|WIKIPATHWAYS|KEGG)', x = msigdb.collec$gs_subcat, ignore.case = TRUE, invert = TRUE),]
msigdb.collec$tag <- paste(msigdb.collec$gs_cat, msigdb.collec$gs_subcat, sep = '.')
msigdb.collec$tag <- sub(pattern = '\\.$', replacement = '', x = msigdb.collec$tag)
msigdb.do <- lapply(msigdb.collec$tag, function(x) { return(msigdb.do.tmp) })
names(msigdb.do) <- msigdb.collec$tag
### Others
do.do <- c(TRUE, TRUE)
go.do <- c(TRUE, TRUE)
kegg.do <- c(TRUE, TRUE)
wp.do <- c(TRUE, TRUE)
reactome.do <- c(TRUE, TRUE)
mesh.do <- c(FALSE, FALSE)

## FALSE
msigdb.do <- c(FALSE, FALSE)
do.do <- c(FALSE, FALSE)
go.do <- c(FALSE, FALSE)
kegg.do <- c(FALSE, FALSE)
wp.do <- c(FALSE, FALSE)
reactome.do <- c(FALSE, FALSE)
mesh.do <- c(FALSE, FALSE)

## Immune Deconvolution
### Common parameters
is_tumor <- FALSE
is_array <- FALSE
### ImmuneDeconv methods
id_methods  <- c(
  'quantiseq'
  , 'epic'
  , 'cibersort'
  , 'mcp_counter'
  , 'abis'
  , 'estimate'
  , 'xcell'
)
### Cibersort
#### Script path
cibersort_binary_path <- '/home/job/WORKSPACE/TOOLS/cibersort/CIBERSORT_v1.06.R'
#### LM22 database
cibersort_lm22_path <- '/home/job/WORKSPACE/TOOLS/cibersort/LM22.txt'
#### Absolute mode
cibersort_absolute <- TRUE

### CiberSortX
# cibersortx_resfile <- NULL
# cibersortx_absolute <- FALSE
cibersortx_resfile <- '/home/job/WORKSPACE/PROJECTS/B24012_GAMO_01_Gabriel.MORIN_GeoMX_RT180.23/RESULTS/B24012_GAMO_01_RT180.23_GeoMx_RNA_20240313211310/ImmuneDeconv/CIBERSORTx_absolute_Results.txt'
cibersortx_absolute <- TRUE

### Factor to use for proportion comparison (from the sample annotation)
prop_factors <- c(
  'PrePost_in_Endothelial'
  , 'PrePost_in_Leucocyte'
  , 'PrePost_in_Epidermis'
  , 'PrePost_in_Endothelial_Leucocyte'
)

## GSVA
### GMT path(s)
gmt_path <- c('/home/job/WORKSPACE/RESOURCES/DATABASE/GMT/Homo_sapiens/BADERLAB/20240301/', '/home/job/WORKSPACE/RESOURCES/DATABASE/GMT/Homo_sapiens/MSigDB/v2023.2.Hs/')

```


## Setup

### Checking dependencies

```{r pkg_check}

cran_list <- c('BiocManager', 'matrixStats', 'remotes', 'readxl', 'ggplot2', 'knitr', 'writexl')
for (pkgn in cran_list) if(! cr %in% installed.packages()) install.packages(pkgn)
bioc_list <- c('DESeq2', 'msigdbr', 'skmeans')
for (pkgn in bioc_list) if(! cr %in% installed.packages()) install.packages(pkgn)

```

### Prepping variables

```{r setup_set, message = FALSE}
## Sourcing outside scripts (for plotting/DEA/GSEA functions)
source('/home/job/gits/customscripts/R/diffexp_design.R')
source('/home/job/gits/customscripts/R/diffexp2gsea.R')

## Clean annotations colname variables
box_categ <- lapply(box_categ, function(x) gsub(pattern = "\\W", replacement = '.', x = x))
conti_categ <- lapply(conti_categ, function(x) gsub(pattern = "\\W", replacement = '.', x = x))
diff_categ <- lapply(diff_categ, function(x) gsub(pattern = "\\W", replacement = '.', x = x))
prop_factors <- lapply(prop_factors, function(x) gsub(pattern = "\\W", replacement = '.', x = x))
covariates <- lapply(covariates, function(x) gsub(pattern = "\\W", replacement = '.', x = x))

## Generate a color palette
listcol <- distinct_color_maker(n_colors = ncolors, my_seed = my_seed)

## Early setup (folders)
analysis_name <- paste(c(analysis_name, format(Sys.time(), '%Y%m%d%H%M%S')), collapse = '_')
work_dir <- paste(c(root_dir, analysis_name), collapse = '/')
dir.create(work_dir, recursive = TRUE)
setwd(work_dir)

## Backup original graphical parameters
oripar <- par(no.readonly = TRUE)

```

## Loading data

```{r data_load}

## Load data
de2 <- readRDS(file = input_RDS)

## Extract sample annotation (to avoid problems with the DESeq2 object structure while knitting)
annot_df <- data.frame(de2@colData, check.names = FALSE)
## Load additional annotations (needs to be synched with the current annot_df). WARNING : except for the annot_sn common column name, any column name in the additional table which is already present in the initial one will REPLACE the initial one !
if (!is.null(annot_filename)) {
  ## Load additinal annotation table
  comp_df <- as.data.frame(readxl::read_excel(path =  annot_filename, na = c('', 'na', 'NA')))
  ## Synch it to the metadata
  comp_df <- comp_df[comp_df[[annot_sn]] %in% annot_df[[annot_sn]],]
  if (nrow(annot_df) !=  nrow(comp_df)) {
    stop('Initial and additional annotation tables are NOT synched : different number of lines (', nrow(annot_df), ' vs ', nrow(comp_df), ') !')
  } else if (all(annot_df[[annot_sn]] != comp_df[[annot_sn]])) {
    stop('Initial and additional annotation tables are NOT synched (different samples order or composition) !')
  } else {
    ## Add new / update columns
    for (newc in colnames(comp_df)[-c(which(colnames(comp_df) == annot_sn))]) annot_df[[newc]] <- comp_df[[newc]]
  }
}

## Clean colnames
colnames(annot_df) <- gsub(pattern = "\\W", replacement = '.', x = colnames(annot_df))

## Convert box_categ entries to factors
for (bcfac in unname(unlist(box_categ))) {
  # message(bcfac)
  annot_df[[bcfac]] <- as.factor(annot_df[[bcfac]])
}
## Same for differential analysis categories
for (defac in diff_categ) annot_df[[defac]] <- as.factor(annot_df[[defac]])

```

# Normalization

Expression is first normalized by computing scaling factors, taking care of batch, then using variance stabilization.

The method used is :

```{r normmethod}
norm_method
```


```{r norm, message=FALSE}
## Computing size factors and dispersion
de2 <- DESeq2::estimateSizeFactors(object = de2)
## Save RAW exp
saveRDS(de2, file = paste0(work_dir, '/DESeq2Obj_Raw.RDS'), compress = 'bzip2')
geo_raw <- SummarizedExperiment::assay(de2)
write.table(x = data.frame(Feature=rownames(geo_raw), geo_raw), file = gzfile(paste0(work_dir, '/Raw_counts_', ncol(geo_raw), 's.tsv.gz')), sep = '\t', quote = FALSE, row.names = FALSE)
rm(geo_raw)
## Normalization
if (tolower(norm_method) == 'vst') {
  message('Normalizing using vst ...')
  de2.norm <- DESeq2::vst(object = de2, blind = TRUE, nsub = 200)
} else if (tolower(norm_method) == 'rlog') {
  message('Normalizing using rlog ...')
  de2.norm <- DESeq2::rlog(object = de2, blind = TRUE)
}
## Extract the normalized matrix
geo_norm <- SummarizedExperiment::assay(de2.norm, normalized = TRUE)
## Save VST
saveRDS(de2.norm, file = paste0(work_dir, '/DESeq2Obj_Norm.', tolower(norm_method), '.RDS'), compress = 'bzip2')
write.table(x = data.frame(Feature = rownames(geo_norm), geo_norm), file = gzfile(paste0(work_dir, '/Normalized.', norm_method, '_counts_', ncol(geo_norm), 's.tsv.gz')), sep = '\t', quote = FALSE, row.names = FALSE)
conti_categ <- unique(c(conti_categ, 'sizeFactor'))
```

## PCA

PCA is used to evaluate how the data dimensionality could be reduced from our multiple samples. Working on human data, we do not expect by default a high representation of the variance by a very limited set of very first components. It is also used to detect outlying samples, and in best cases gives ideas of the data structure (ie, most evident clusters).

```{r pca, message=FALSE, eval = FALSE}
## PCAs on normalized assay
for (bc in names(box_categ)) {
  suppressWarnings(de2.pca.batch <- DESeq2::plotPCA(de2.norm, intgroup = box_categ[[bc]]))
  suppressWarnings(print(de2.pca.batch + ggplot2::geom_point(data = data.frame(PC1 = get_medoid(x = de2.pca.batch$data$PC1, split = de2.pca.batch$data$group), PC2 = get_medoid(x = de2.pca.batch$data$PC2, split = de2.pca.batch$data$group), group = unique(de2.pca.batch$data$group)), shape = 13, size = 8) + ggplot2::labs(title = bc)))
}

```

*Conclusion* :

* PC1 represents ~ XX% of the total variance.
* Lorem.
* Ipsum.

# Unsupervized analyses

## Clustering

### Hierarchical

Hierarchical clustering is the rough, basic family of clustering methods. It has several variations based on its two main steps : 

* Computation of distances between all pairs of samples : there are multiple types of computing a distance between entities (mainly, in genomics : Euclidean, pearson/spearman, manhattan, maximum, ...).
* Aglomeration method, the way to construct a structure from the collection (half-matrix) of distances : as well, there are multiple methods (mainly : Ward, complete, median, ...)

As we have no a priori clue of the expression pattern of the differences between conditions / samples, we cannot know which distance and aglomeration method combination is better suited to measure these differences. Thus, multiple methods should be tested.

```{r hclust}

```

### Skmeans



```{r skmeans}

```

### NMF

# Differential analysis

## Assess covariates

```{r diffexp}
diff_dir <- paste0(work_dir, '/Differential_analysis')
dir.create(path = diff_dir, recursive = TRUE)
topword <- if (!is.null(topvar)) paste0('topvar.', topvar) else topvar
assess_covar(mat = geo_norm, annot.df = annot_df, factor.names = unname(unlist(box_categ)), conti.names = unname(unlist(conti_categ)), red.method = 'pca', ndim.max = 10, topvar = topvar, center = TRUE, scale = TRUE, out.file = paste0(diff_dir, '/', paste(c('covar_raw', topword), collapse = '_'), '.png'))

```

## DESeq2

### Generate the default design table

```{r destab}
## Generating the full design file
my_des <- full_design_generator(
  init_df = annot_df[,c(annot_sn, unlist(diff_categ))]
  , samples_colname = annot_sn
  , covar_colnames = covariates
  , add_inverted = TRUE
  , add_others = TRUE
  , only_others = FALSE)

## POST vs PRE only
my_des <- my_des[!my_des$Condition_A %in% c('pre'),]

## Display the design table
knitr::kable(my_des)

```


### DEA on all possible comparisons

Differential expression analysis is performed using DESeq2 on the generated design.

```{r dea_all, eval = FALSE}
suppressMessages(
  DE_test(
  ## Raw count matrix
  exp.mat = de2@assays@data@listData$counts
  ## Sample annotation
  , annot.df = annot_df
  ## Design table
  , design.df = my_des
  ## Factors to evaluate as putative categorical covariates
  , assess.factor = unname(unlist(box_categ))
  ## Numerics to evaluate as putative continuous covariates
  , assess.conti = unname(unlist(conti_categ))
  ## Max FDR-adjusted p-value threshold for differential features
  , adjp.max = adjp.max
  ## Min abs(log2FoldChange)to identify differential features
  , lfc.min = lfc.min
  ## Perform ihw log2FoldChange adjustment
  , ihw = TRUE
  ## Perform log2FoldChange shrinking on lower values
  , lfcShrink = TRUE
  ## Max FDR-adjusted p-value threshold for enriched GSEA/ORA terms
  , enrp.max = adjp.max
  ## Distance(s) for samples to use for hierarchical clustering on differentially expressed features
  , samples.dist.method = samples_dist_method
  ## Minimal size of significant features to run GSEA / ORA
  , enr.min.genes = enr_min_genes
  ## Use the MSigDB resources (through msigdbr) for GSEA / ORA
  , msigdb.do = msigdb.do
  ## Use the DiseaseOntology resources (through DOSE) for GSEA / ORA
  , do.do = do.do
  ## Use the GeneOntology resources for GSEA / ORA
  , go.do = go.do
  ## Use the KEGG/MKEGG resources for GSEA / ORA
  , kegg.do = kegg.do
  ## Use the WikiPathways resources for GSEA / ORA
  , wp.do = wp.do
  ## Use the Reactome resources for GSEA / ORA
  , reactome.do = reactome.do
  ## Use the NCBI MeSH resources for GSEA / ORA (*not recommended*)
  , mesh.do = mesh.do
  ## Species name (to convert symbols to EntrezId)
  , species = species
  ## RNG seed
  , my.seed = my_seed
  ## Save the Wald test results as RDS (can be huge)
  , save.wald = TRUE
  ## Path to result files
  , outdir = work_dir
  )
)

```

*NOTE* : DEA generates numerous tables, data archives and plots (thousands), thus results are not available in this report.

# Immune deconvolution

. This analysis will attempt an estimation of the immune composition of each of the expression profiles.
. This is performed thanks to the [*immunedeconv*](https://github.com/omnideconv/immunedeconv) R package, which regroups multiple methods.
. Most methods require expression data to be in TPM (transcripts per million : the sum of all counts in a sample always equals 1E+06), not normalized (vst, etc) not log-scaled
. All tested methods can be used to compare proportions/scores across samples or sample groups.
. Most methods have their specificities :
  . QuantiSeq : returns proportions (between 0 and 1)
  . EPIC : same as QuantiSeq, but is the only one that also computes the fraction of uncharachterized cells
  . MCPCounter : scores each cell mixture in arbitrary units
  . CiberSort (v1.06) : must be run here in "absolute" mode to allow comparison across samples
  . CiberSortX : same as CiberSort, but is more recent and trained on scRNAseq data. Was manually performed [online](https://cibersortx.stanford.edu/).
  . ESTIMATE : simpler algotithm that was designed for evaluation of tumoral purity. Consequently, does not return fractions for specific immune subpopulations but 4 scores (global "estimate", immune, stroma and tumor)


## Deconvolution

```{r id_deconv}

## Output directory
id_dir <- paste0(root_dir, '/ImmuneDeconv')
dir.create(path = id_dir)

## Run immunedeconv
id_res_all <- immunedeconv_run(
  exp_mat = de2@assays@data$counts
  , to_tpm = TRUE
  , methods = id_methods
  , is_array = is_array
  , is_tumor = is_tumor
  , cibersort_binary_path = cibersort_binary_path
  , cibersort_lm22_path = cibersort_lm22_path
  , cibersort_absolute = cibersort_absolute
  , cibersortx_resfile = cibersortx_resfile
  , cibersortx_absolute = cibersortx_absolute
)

## Save results
writexl::write_xlsx(x = id_res_all, path = paste0(id_dir, '/immunedeconv_results.xlsx'), col_names = TRUE, format_headers = TRUE)

```

## Barplots

```{r id_barplots}

## Barplots
for (idm in names(id_res_all)) {
  message(idm)
  immunedeconv_barplot(id_res = id_res_all[[idm]], title = idm)
}

```


## Proportion tests

The association of proportion differences with sample annotations is tested through a Kruskal-Wallis test.

```{r id_testprop}

## Looping on factors to compare
kw_all <- lapply(prop_factors, function(ppf) {
  # message(ppf)
  ## Looping on methods
  kw_idm <- lapply(names(id_res_all), function(idn) {
    # message('\t',idn)
    ## Looping on cell types
    kw_l <- sapply(seq_len(nrow(id_res_all[[idn]])), function(x) {
      # message(x)
      ## Perform KW test
      data_df <- data.frame(props = unname(unlist(id_res_all[[idn]][x,-1])), class = annot_df[[ppf]])
      kw_t <- kruskal.test(props ~ class, data = data_df)
      k_df <- data.frame(Statistic = kw_t$statistic, raw.p = kw_t$p.value, adj.p = 0.0)
      ## Add classes median
      ksumry <- aggregate(props ~ class, data = data_df, summary)
      ksd <- aggregate(props ~ class, data = data_df, sd)
      for (kx in seq_len(nrow(ksumry$props))) {
        k_df[[paste0('Median_', ksumry$class[kx])]] <- ksumry$props[kx, 'Median']
        k_df[[paste0('Sd_', ksd$class[kx])]] <- ksd$props[kx]
      }
      ## Return
      return(k_df)
    }, simplify = FALSE)
    
    kw_res <- data.frame(Cell_type = paste0(idn, '_', unlist(id_res_all[[idn]][,1])), Reduce(f = rbind, x = kw_l))
    rownames(kw_res) <- paste0(idn, '_', gsub(pattern = "\\W", replacement = '.', x = kw_res$Cell_type))
    return(kw_res)
  })
  names(kw_idm) <- names(id_res_all)
  KWX <- Reduce(f = rbind, kw_idm)
  KWX$adj.p <- p.adjust(p = KWX$raw.p, method = "BH")
  return(KWX)
})
names(kw_all) <- prop_factors

## Save results
writexl::write_xlsx(x = kw_all, path = paste0(id_dir, '/immunedeconv_prop_test_results.xlsx'), col_names = TRUE, format_headers = TRUE)

```


# Gene Set Variance Analysis (GSVA)

. This analysis attempts to compare the expression pattern of each expression profile to a list of banks of knowledge, consisting in (functional) terms associated to known gene signatures. The output is a positive or negative association, with a significance test p-value between the expression profile and terms.
. This is analoguous to GSEA (gene set enrichment analysis) but performed at the sample expression profile level, rather than at the differential expression profile level. In the former, direct expression level is used ; in the latter, logFoldChange/AdjP/Test-statistic is used.
. This is performed using the [*GSVA*](https://bioconductor.org/packages/release/bioc/vignettes/GSVA/inst/doc/GSVA.html) R package.

## GSVA

```{r gsva, eval = FALSE, echo = FALSE}

## Output directories
gsva_dir <- paste0(root_dir, '/GSVA')
gsva_res_dir <- paste0(gsva_dir, '/Results')
gsva_diff_dir <- paste0(gsva_dir, '/Diff_tests')
dir.create(path = gsva_res_dir, recursive = TRUE)
dir.create(path = gsva_diff_dir, recursive = TRUE)

## Get list of GMT files to use
gmt_files <- list.files(path = gmt_path, pattern = 'entrez.*\\.gmt.*$', full.names = TRUE, recursive = TRUE, ignore.case = TRUE)

## Discard MSigDB GO GMTs (older than BADERLAB versions) and PFOCR (automatic, large)
gmt_files <- gmt_files[!grepl(pattern = '(PFOCR|\\.go\\.)', x = gmt_files)]

## Generate GMT names (for output)
gmt_names <- sub(pattern = '\\.gmt.*$', replacement = '', x = basename(gmt_files))

## Run GSVA
gsva_all <- gsva_run(
  exp_mat = geo_norm
  , gmt_files = gmt_files
  , enr_min_genes = enr_min_genes
  , species = species
  , out_dir = gsva_res_dir
)

```


## Differential tests

We can perform differential test across sample annotations on the GSVA scores

```{r gsva_diff, eval = FALSE, echo = FALSE}

gdiff_all <- gsva_diff_run(
  gsva_res = gsva_all
  , annot_df = annot_df
  , diff_factor = prop_factors
  , max.p = adjp.max
  , out_dir = gsva_diff_dir
)

```


# Rsession

```{r sessioninfo}

sessionInfo()

```

